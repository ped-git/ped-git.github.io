<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± ŸÇÿ±ÿ¢ŸÜ</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rastikerdar/shabnam-font@v5.0.1/dist/font-face.css">
    <style>
        @font-face {
            font-family: 'Sahel';
            src: url('/fonts/Sahel.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'KFGQPC Uthman Taha Naskh';
            src: url('fonts/KFGQPC Uthman Taha Naskh Regular.ttf') format('truetype');
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 8px;
            font-family: 'Sahel', 'KFGQPC Uthman Taha Naskh', Arial, sans-serif;
            background: #f5f5f5;
            direction: rtl;
        }
        
        .container {
            width: 100%;
        }
        
        .search-box {
            background: white;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            margin-bottom: 8px;
        }
        
        .search-row {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
        }
        
        .search-input-wrapper {
            position: relative;
            flex: 1;
            min-width: 200px;
        }
        
        .search-input {
            width: 100%;
            padding: 8px 12px;
            font-size: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
            direction: rtl;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #3498db;
        }
        
        .suggestions {
            position: absolute;
            top: 100%;
            right: 0;
            left: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .suggestions.visible {
            display: block;
        }
        
        .suggestion-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .suggestion-item:last-child {
            border-bottom: none;
        }
        
        .suggestion-item:hover {
            background: #f0f7ff;
        }
        
        .suggestion-item.text {
            background: #fff8e1;
        }
        
        .suggestion-item.word {
            background: #e3f2fd;
        }
        
        .suggestion-item.root {
            background: #e8f5e9;
        }
        
        .suggestion-type {
            font-size: 11px;
            color: #888;
            padding: 2px 6px;
            border-radius: 4px;
            background: #f0f0f0;
        }
        
        .distance-control {
            display: inline-flex;
            align-items: center;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 999px;
            overflow: hidden;
            background: #fff;
        }

        /* Digits are produced via Intl.NumberFormat('fa-IR'); keep the normal UI font */
        .num-hindi {
            font-family: "Shabnam", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
            font-size: calc(1em * var(--ui-font-scale));
        }

        .distance-input {
            width: 38px;
            height: 30px;
            border: none;
            padding: 0 4px;
            font-size: calc(13px * var(--ui-font-scale));
            text-align: center;
            /* Ensure the visible glyph uses Shabnam */
            font-family: "Shabnam", "Vazirmatn", system-ui, -apple-system, "Segoe UI", Arial, sans-serif;
            outline: none;
            appearance: textfield;
            -moz-appearance: textfield;
            background: transparent;
            line-height: 1;
        }

        /* Distance: show formatted (fa-IR) digits, keep actual numeric input hidden for parsing */
        .distance-control.has-display {
            position: relative;
        }

        .distance-control.has-display .distance-input {
            color: transparent;
            text-shadow: none;
            caret-color: #333;
        }

        .distance-display {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            font-size: calc(13px * var(--ui-font-scale));
            line-height: 1;
            color: #333;
        }

        /* Hide number input spinners (arrows) */
        .distance-input::-webkit-outer-spin-button,
        .distance-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .cross-sura-toggle {
            border: 1px solid #ddd;
            background: #f8f8f8;
            color: #333;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 13px;
            cursor: pointer;
            font-family: inherit;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            transition: background 0.2s, border-color 0.2s;
            height: 34px;
        }

        .cross-sura-toggle:hover {
            background: #f0f0f0;
        }

        .cross-sura-toggle[aria-pressed="true"] {
            background: #e3f2fd;
            border-color: #90caf9;
        }

        .cross-sura-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #bbb;
        }

        .cross-sura-toggle[aria-pressed="true"] .cross-sura-dot {
            background: #3498db;
        }

        .auto-update-toggle {
            border: 1px solid #ddd;
            background: #f8f8f8;
            color: #333;
            border-radius: 999px;
            padding: 6px 10px;
            cursor: pointer;
            font-family: inherit;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            user-select: none;
            height: 34px;
            transition: background 0.2s, border-color 0.2s;
            position: relative;
        }

        .auto-update-toggle input {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
        }

        .auto-update-toggle .auto-update-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #bbb;
        }

        .auto-update-toggle.on {
            background: #e3f2fd;
            border-color: #90caf9;
        }

        .auto-update-toggle.on .auto-update-dot {
            background: #3498db;
        }
        
        .distance-label {
            color: #666;
            font-size: 13px;
        }
        
        .search-btn {
            padding: 8px 20px;
            font-size: 14px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        
        .search-btn:hover {
            background: #2980b9;
        }
        
        .search-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .selected-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .selected-items {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            flex: 1;
            min-height: 28px;
            padding: 4px 8px;
            background: #fafafa;
            border-radius: 6px;
            border: 1px dashed #ddd;
            align-items: center;
        }
        
        .selected-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: 500;
            color: #333;
        }
        
        /* Match highlight colors */
        .selected-item.color-0 { background: #a5d6a7; }
        .selected-item.color-1 { background: #90caf9; }
        .selected-item.color-2 { background: #ffcc80; }
        .selected-item.color-3 { background: #ce93d8; }
        .selected-item.color-4 { background: #fff59d; }
        .selected-item.color-5 { background: #f48fb1; }
        .selected-item.color-6 { background: #80deea; }
        .selected-item.color-7 { background: #bcaaa4; }
        
        .selected-item .remove-btn {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgba(0,0,0,0.15);
            color: #333;
            border: none;
            cursor: pointer;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .selected-item .remove-btn:hover {
            background: rgba(0,0,0,0.25);
        }
        
        .view-results-toggle {
            border: 1px solid #ddd;
            background: #f8f8f8;
            color: #333;
            border-radius: 999px;
            padding: 6px 10px;
            font-size: 13px;
            cursor: pointer;
            font-family: inherit;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            transition: background 0.2s, border-color 0.2s;
            height: 34px;
        }
        .view-results-toggle:hover {
            background: #f0f0f0;
        }
        .view-results-toggle[aria-pressed="true"] {
            background: #e3f2fd;
            border-color: #90caf9;
        }
        .view-results-toggle .view-results-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #bbb;
        }
        .view-results-toggle[aria-pressed="true"] .view-results-dot {
            background: #3498db;
        }
        .results-count {
            color: #666;
            font-size: calc(12px * var(--ui-font-scale));
            white-space: nowrap;
        }
        
        .empty-hint {
            color: #999;
            font-size: 12px;
        }
        
        .results-box {
            display: flex;
            flex-direction: row-reverse; /* RTL fix: items panel on right */
            gap: 10px;
            background: transparent;
            padding: 0;
            border-radius: 0;
            box-shadow: none;
        }
        
        .results-content-column {
            flex: 1;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            min-height: 200px;
        }
        
        .items-panel {
            width: 240px;
            flex-shrink: 0;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            max-height: 80vh;
            overflow-y: auto;
            position: sticky;
            top: 10px;
        }
        
        .items-panel-title {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            color: #333;
        }
        
        .search-item-row {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .search-item-row:hover {
            background: #f5f5f5;
        }
        
        .search-item-row.highlighted {
            background: #e3f2fd;
            border: 1px solid #90caf9;
        }
        
        .search-item-row.unchecked {
            opacity: 0.5;
        }
        
        .search-item-row.unchecked .item-label {
            text-decoration: line-through;
        }
        
        .search-item-row .item-checkbox {
            margin: 0;
            cursor: pointer;
        }
        
        .search-item-row .item-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .search-item-row .item-label {
            flex: 1;
            font-size: 13px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .search-item-row .item-type {
            font-size: 10px;
            color: #888;
            background: #f0f0f0;
            padding: 1px 4px;
            border-radius: 3px;
        }
        
        .lems-container {
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .lems-container.collapsed {
            max-height: 0 !important;
        }
        
        .expand-toggle {
            cursor: pointer;
            font-size: 10px;
            color: #666;
            transition: transform 0.2s;
            user-select: none;
            width: 12px;
            text-align: center;
        }
        
        .expand-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .expand-spacer {
            width: 12px;
            flex-shrink: 0;
        }
        
        .lem-subrow {
            padding: 4px 24px 4px 8px; /* RTL: indent on right */
            margin-bottom: 2px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .lem-subrow:hover {
            background: #f8f8f8;
        }
        
        .lem-subrow.highlighted {
            background: #e8f5e9;
            border: 1px solid #a5d6a7;
        }
        
        .lem-subrow.unchecked {
            opacity: 0.5;
        }
        
        .lem-subrow.unchecked .lem-label {
            text-decoration: line-through;
        }
        
        .lem-subrow input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }
        
        .lem-subrow .lem-label {
            flex: 1;
        }
        
        .lem-subrow .lem-count {
            font-size: 10px;
            color: #888;
        }
        
        .result-group {
            padding: 8px 10px;
            margin-bottom: 8px;
            background: #fafafa;
            border-radius: 6px;
            border-right: 3px solid #3498db;
            position: relative;
            overflow: visible;
        }
        
        .region-controls {
            position: absolute;
            top: -2px; /* inside the region, overlay on top */
            left: 6px;
            transform: none;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 0;
            backdrop-filter: none;
            z-index: 2;
        }

        .result-group:hover .region-controls {
            opacity: 1;
            pointer-events: auto;
        }

        .region-btn {
            border: none;
            background: transparent;
            width: 14px;
            height: 14px;
            padding: 0;
            font-size: 11px;
            cursor: pointer;
            font-family: inherit;
            color: #111;
            line-height: 1;
            white-space: nowrap;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: none;
            opacity: 0.95;
        }

        .region-btn:hover {
            opacity: 1;
        }

        .region-btn svg {
            width: 14px;
            height: 14px;
            display: block;
        }

        .region-btn.before {
            color: #111; /* black like screenshot */
        }

        .region-btn.after {
            color: #1565c0; /* blue like screenshot */
        }

        .region-btn.reset {
            color: #555;
        }

        .region-btn.danger {
            color: #c62828; /* red X */
        }

        .region-btn.danger:hover {
            opacity: 1;
        }

        /* Ensure left-outside controls are not clipped by containers */
        .multi-sura-container {
            overflow: visible;
        }

        .result-group:last-child {
            margin-bottom: 0;
        }
        
        /* Connected groups from same cross-sura interval */
        .multi-sura-container {
            border-right: 3px solid #3498db;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        
        .multi-sura-container .result-group {
            border-right: none;
            border-radius: 0;
            margin-bottom: 0;
            border-bottom: 1px dashed #ccc;
        }
        
        .multi-sura-container .result-group:first-child {
            border-radius: 6px 6px 0 0;
        }
        
        .multi-sura-container .result-group:last-child {
            border-radius: 0 0 6px 6px;
            border-bottom: none;
        }
        
        .result-ayah {
            display: inline;
            line-height: var(--ayah-line-height);
            font-size: var(--ayah-font-size);
        }
        
        .result-ref {
            display: inline-block;
            font-size: calc(10px * var(--ui-font-scale));
            color: #888;
            background: #e8e8e8;
            padding: 1px 6px;
            border-radius: 3px;
            margin-right: 8px;
            vertical-align: middle;
            text-decoration: none;
        }
        
        .sura-row {
            line-height: 2;
        }
        
        .highlight {
            padding: 1px 3px;
            border-radius: 2px;
        }
        
        :root {
            /* Shabnam (UI font) runs a bit larger; scale it down */
            --ui-font-scale: 0.8;
            --ayah-font-size: 17px;
            --ayah-line-height: 2;
            --ayah-font-size-qcf: 17px;
            --ayah-line-height-qcf: 2;

            --color-0: #a5d6a7; /* Light green */
            --color-1: #90caf9; /* Light blue */
            --color-2: #ffcc80; /* Light orange */
            --color-3: #ce93d8; /* Light purple */
            --color-4: #fff59d; /* Light yellow */
            --color-5: #f48fb1; /* Light pink */
            --color-6: #80deea; /* Light cyan */
            --color-7: #bcaaa4; /* Light brown */

            /* Darker text colors for "text highlight" mode */
            --tcolor-0: #2e7d32;
            --tcolor-1: #1565c0;
            --tcolor-2: #ef6c00;
            --tcolor-3: #6a1b9a;
            --tcolor-4: #8d6e00;
            --tcolor-5: #ad1457;
            --tcolor-6: #00838f;
            --tcolor-7: #5d4037;
        }
        
        .highlight-0 { background: var(--color-0); }
        .highlight-1 { background: var(--color-1); }
        .highlight-2 { background: var(--color-2); }
        .highlight-3 { background: var(--color-3); }
        .highlight-4 { background: var(--color-4); }
        .highlight-5 { background: var(--color-5); }
        .highlight-6 { background: var(--color-6); }
        .highlight-7 { background: var(--color-7); }

        /* Results view options */
        .results-box.view-rows .sura-row {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .ayah-row {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }

        .ayah-ref-leading {
            display: inline-block;
            font-size: calc(11px * var(--ui-font-scale));
            color: #666;
            background: #e8e8e8;
            padding: 1px 6px;
            border-radius: 3px;
            white-space: nowrap;
            flex: 0 0 auto;
            text-decoration: none;
        }

        /* Highlight mode: text color instead of background (only affects results) */
        .results-box.highlight-text .highlight {
            background: transparent !important;
            padding: 0 !important;
            border-radius: 0 !important;
            font-weight: 700;
        }

        .results-box.highlight-text .highlight-0 { color: var(--tcolor-0) !important; }
        .results-box.highlight-text .highlight-1 { color: var(--tcolor-1) !important; }
        .results-box.highlight-text .highlight-2 { color: var(--tcolor-2) !important; }
        .results-box.highlight-text .highlight-3 { color: var(--tcolor-3) !important; }
        .results-box.highlight-text .highlight-4 { color: var(--tcolor-4) !important; }
        .results-box.highlight-text .highlight-5 { color: var(--tcolor-5) !important; }
        .results-box.highlight-text .highlight-6 { color: var(--tcolor-6) !important; }
        .results-box.highlight-text .highlight-7 { color: var(--tcolor-7) !important; }
        
        .no-results {
            text-align: center;
            color: #999;
            padding: 20px;
            font-size: 14px;
        }
        .item-stats-card {
            border: 1px solid #d9d9d9;
            border-radius: 8px;
            background: #fff;
            padding: 10px 12px;
            margin-bottom: 12px;
        }
        .item-stats-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .item-stats-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex: 0 0 10px;
        }
        .item-stats-title {
            font-weight: 700;
            color: #243447;
        }
        .item-stats-type {
            color: #6b7280;
            font-size: 12px;
            background: #f2f4f6;
            border-radius: 999px;
            padding: 1px 8px;
        }
        .item-stats-total {
            margin-right: auto;
            color: #334155;
            font-size: 13px;
        }
        .stats-panel-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 2px 0 10px;
        }
        .stats-found-suras {
            color: #334155;
            font-size: 12px;
        }
        .stats-match-toggle {
            border: 1px solid #ddd;
            background: #f8f8f8;
            color: #333;
            border-radius: 999px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }
        .stats-match-toggle .stats-match-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #bbb;
        }
        .stats-match-toggle[aria-pressed="true"] {
            background: #e3f2fd;
            border-color: #90caf9;
            color: #0f4fa8;
        }
        .stats-match-toggle[aria-pressed="true"] .stats-match-dot {
            background: #3498db;
        }
        .stats-sort-controls {
            margin-right: auto;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .stats-sort-select {
            border: 1px solid #ddd;
            background: #fff;
            border-radius: 6px;
            padding: 4px 6px;
            font-size: 12px;
            color: #334155;
        }
        .stats-sort-dir-btn {
            border: 1px solid #ddd;
            background: #f8f8f8;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            color: #334155;
        }
        .item-stats-table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            font-size: 13px;
        }
        .item-stats-table th,
        .item-stats-table td {
            border-bottom: 1px solid #eceff1;
            padding: 6px 4px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .item-stats-table th {
            color: #3a556a;
            font-weight: 700;
            background: #fafbfc;
        }
        .item-stats-table th[data-sort-key] {
            cursor: pointer;
            user-select: none;
        }
        .item-stats-table .measure-help {
            cursor: help;
        }
        .item-stats-chart-wrap {
            border: 1px solid #e7ecef;
            border-radius: 8px;
            background: #fcfdff;
            padding: 8px;
        }
        .item-stats-chart {
            width: 100%;
            height: 340px;
            display: block;
        }
        .chart-x-label {
            font-size: 10px;
            fill: #64748b;
        }
        .chart-y-label {
            font-size: 10px;
            fill: #64748b;
        }
        .chart-axis-line {
            stroke: #dbe3ea;
            stroke-width: 1;
        }
        .chart-series-line {
            fill: none;
            stroke-width: 2;
        }
        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 8px;
        }
        .chart-legend-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #334155;
        }
        .chart-legend-swatch {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            display: inline-block;
        }
        .stats-sura-link {
            color: #1d4ed8;
            text-decoration: none;
        }
        .stats-sura-link:hover {
            text-decoration: underline;
        }
        .stats-sura-count {
            cursor: pointer;
            color: #1d4ed8;
        }
        .stats-sura-count:hover {
            text-decoration: underline;
        }
        #measure-tooltip {
            position: fixed;
            z-index: 10000;
            max-width: 340px;
            background: #1f2937;
            color: #fff;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 12px;
            line-height: 1.45;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.28);
            pointer-events: none;
            opacity: 0;
            transform: translateY(2px);
            transition: opacity 0.12s ease, transform 0.12s ease;
        }
        #measure-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }
        #measure-tooltip .title {
            font-weight: 700;
            margin-bottom: 4px;
            color: #93c5fd;
        }
        #measure-tooltip .formula-render {
            direction: ltr;
            text-align: left;
            font-size: 12px;
            color: #f3f4f6;
            margin-bottom: 6px;
            font-family: "Times New Roman", serif;
        }
        #measure-tooltip .frac {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            vertical-align: middle;
            margin: 0 2px;
            line-height: 1.05;
        }
        #measure-tooltip .frac .num {
            border-bottom: 1px solid #cbd5e1;
            padding: 0 2px 1px 2px;
        }
        #measure-tooltip .frac .den {
            padding: 1px 2px 0 2px;
        }
        #measure-tooltip .var-line {
            margin-top: 2px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }
        
        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        .sura-name {
            font-weight: bold;
            color: #2c3e50;
        }
        
        .settings-btn {
            padding: 8px 12px;
            font-size: 16px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .settings-btn:hover {
            background: #e0e0e0;
        }

        /* Split search button (Gmail-like): main search + dropdown arrow */
        .search-split {
            position: relative;
            display: inline-flex;
            align-items: stretch;
            direction: ltr; /* keep arrow segment visually on the right, like Gmail */
        }

        .search-split .search-btn {
            border-radius: 8px 0 0 8px;
        }

        .embed-add-btn {
            margin-right: 8px;
            border-radius: 8px !important;
        }
        .search-embed-mode .embed-add-btn {
            margin-right: 0;
        }
        .embed-add-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .search-drop-btn {
            background: #3498db;
            color: #fff;
            border: none;
            cursor: pointer;
            width: 36px;
            padding: 0;
            border-radius: 0 8px 8px 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
            border-left: 1px solid rgba(255,255,255,0.35);
        }

        .search-drop-btn:hover {
            background: #2980b9;
        }

        .search-drop-btn:disabled,
        .search-split .search-btn:disabled + .search-drop-btn {
            background: #bdc3c7; /* match .search-btn:disabled */
            color: white;
            cursor: not-allowed;
        }

        .copy-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 5px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1002;
            min-width: 160px;
        }

        .copy-menu.visible {
            display: block;
        }

        .copy-menu-item {
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
        }

        .copy-menu-item:hover {
            background: #f5f5f5;
        }
        
        .settings-wrapper {
            position: relative;
        }
        
        .settings-menu {
            display: none;
            /* Positioned via Floating UI (prevents off-screen in RTL + narrow widths) */
            position: fixed;
            top: 0;
            left: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1001;
            min-width: 220px;
            max-width: calc(100vw - 16px);
        }
        
        .settings-menu.visible {
            display: block;
        }
        
        .settings-title {
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .settings-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .settings-item label {
            font-size: 13px;
            color: #555;
            white-space: nowrap;
        }
        
        .settings-item select {
            flex: 1;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            font-size: 13px;
        }
        
        .apply-btn {
            width: 100%;
            padding: 8px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
        }
        
        .apply-btn:hover {
            background: #2980b9;
        }

        .desktop-link {
            display: block;
            margin-top: 8px;
            width: 100%;
            text-align: center;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid #d6e7fb;
            background: #f3f9ff;
            color: #1e6fbf;
            text-decoration: none;
            font-family: inherit;
            font-size: 13px;
        }

        .desktop-link:hover {
            background: #e8f3ff;
            border-color: #c6defa;
        }
        
        /* Sura filter */
        .sura-filter-wrapper {
            position: relative;
        }
        
        .sura-filter-btn {
            padding: 8px 12px;
            font-size: 13px;
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
        }
        
        .sura-filter-btn:hover {
            background: #f0f0f0;
        }
        
        .sura-filter-btn .filter-count {
            background: #3498db;
            color: white;
            font-size: 11px;
            padding: 1px 6px;
            border-radius: 10px;
        }
        
        .sura-filter-popup {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 5px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1002;
            width: 320px;
            max-height: 400px;
            overflow: hidden;
            display: none;
            flex-direction: column;
        }
        
        .sura-filter-popup.visible {
            display: flex;
        }
        
        .sura-filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        
        .sura-filter-header span {
            font-weight: bold;
            font-size: 13px;
        }
        
        .sura-filter-actions {
            display: flex;
            gap: 8px;
        }
        
        .sura-filter-actions button {
            padding: 4px 8px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f8f8f8;
            cursor: pointer;
            font-family: inherit;
        }
        
        .sura-filter-actions button:hover {
            background: #e8e8e8;
        }
        
        .sura-filter-search {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 8px;
            font-family: inherit;
        }
        
        .sura-filter-list {
            flex: 1;
            overflow-y: auto;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            max-height: 280px;
        }
        
        .sura-filter-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .sura-filter-item:hover {
            background: #f5f5f5;
        }
        
        .sura-filter-item.hidden {
            display: none;
        }
        
        .sura-filter-item input {
            margin: 0;
            cursor: pointer;
        }
        
        .sura-filter-item .sura-num {
            color: #888;
            font-size: calc(10px * var(--ui-font-scale));
            min-width: 18px;
        }
        
        .sura-filter-item .sura-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* Quran.com QCF font style */
        body.font-qurancom .result-ayah {
            font-size: var(--ayah-font-size-qcf);
            line-height: var(--ayah-line-height-qcf);
        }
        
        body.font-qurancom .qcf-word {
            display: inline-block;
            direction: rtl;
        }
        body.font-bbadr .result-ayah {
            font-family: 'B Badr', 'BBadr', 'BLotus', 'KFGQPC Uthman Taha Naskh', serif;
        }
        
        /* Loading indicator for quran.com font */
        .qcf-loading {
            color: #999;
            font-style: italic;
            font-size: 14px;
        }
    </style>
    
    <!-- QCF page fonts will be loaded dynamically -->
</head>
<body>
    <div class="container">
        <div class="search-box">
            <div class="search-row">
                <div class="search-input-wrapper">
                    <input type="text" class="search-input" id="search-input" placeholder="Ÿàÿß⁄òŸá €åÿß ÿ±€åÿ¥Ÿá ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ..." autocomplete="off">
                    <div class="suggestions" id="suggestions"></div>
                </div>
                <div class="sura-filter-wrapper">
                    <button class="sura-filter-btn" id="sura-filter-btn" type="button">
                        üìñ <span id="sura-filter-label">ŸáŸÖŸá ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß</span>
                    </button>
                    <div class="sura-filter-popup" id="sura-filter-popup">
                        <div class="sura-filter-header">
                            <span>ÿßŸÜÿ™ÿÆÿßÿ® ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß</span>
                            <div class="sura-filter-actions">
                                <button type="button" id="sura-select-all">ŸáŸÖŸá</button>
                                <button type="button" id="sura-select-none">Ÿá€å⁄Ü</button>
                            </div>
                        </div>
                        <input type="text" class="sura-filter-search" id="sura-filter-search" placeholder="ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ÿ≥Ÿàÿ±Ÿá...">
                        <div class="sura-filter-list" id="sura-filter-list"></div>
                    </div>
                </div>
                <div class="distance-control has-display" id="distance-control" title="ŸÅÿßÿµŸÑŸá (ÿ™ÿπÿØÿßÿØ ÿ¢€åŸá) ‚Äî ÿ™ÿ∫€å€åÿ± ÿ®ÿß Ÿæ€åŸÖÿß€åÿ¥ ŸÖŸàÿ¥‚ÄåŸàÿßÿ±Ÿá €åÿß ⁄©ŸÑ€åÿØŸáÿß€å ‚Üë‚Üì" aria-label="ŸÅÿßÿµŸÑŸá (ÿ™ÿπÿØÿßÿØ ÿ¢€åŸá)">
                    <input type="text" class="distance-input" id="distance-input" value="5" inputmode="numeric" pattern="[0-9€∞-€πŸ†-Ÿ©]*" autocomplete="off" spellcheck="false" aria-label="ŸÅÿßÿµŸÑŸá" lang="fa">
                    <div class="distance-display num-hindi" id="distance-display" aria-hidden="true"></div>
                </div>
                <button type="button" class="cross-sura-toggle" id="cross-sura-toggle" aria-pressed="false" title="ŸàŸÇÿ™€å ÿ±Ÿàÿ¥ŸÜ ÿ®ÿßÿ¥ÿØÿå €å⁄© ⁄Øÿ±ŸàŸá ÿ¢€åŸá ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ¥ÿßŸÖŸÑ ⁄ÜŸÜÿØ ÿ¢€åŸá ÿßÿ≤ ÿßŸÜÿ™Ÿáÿß€å €å⁄© ÿ≥Ÿàÿ±Ÿá Ÿà ⁄ÜŸÜÿØ ÿ¢€åŸá ÿßÿ≤ ÿßÿ®ÿ™ÿØÿß€å ÿ≥Ÿàÿ±Ÿá ÿ®ÿπÿØ€å ÿ®ÿßÿ¥ÿØ.">
                    <span class="cross-sura-dot" aria-hidden="true"></span>
                    ÿ®€åŸÜ ÿ≥Ÿàÿ±Ÿá
                </button>
                <label class="auto-update-toggle on" id="auto-update-toggle" title="ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿÆŸàÿØ⁄©ÿßÿ±: ÿ®ÿß Ÿáÿ± ÿ™ÿ∫€å€åÿ±ÿå ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØŸàÿ®ÿßÿ±Ÿá ÿßÿ¨ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ">
                    <input type="checkbox" id="auto-update" checked aria-label="ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿÆŸàÿØ⁄©ÿßÿ±: ÿ®ÿß Ÿáÿ± ÿ™ÿ∫€å€åÿ±ÿå ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØŸàÿ®ÿßÿ±Ÿá ÿßÿ¨ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ">
                    <span class="auto-update-dot" aria-hidden="true"></span>
                </label>
                <div class="search-split">
                    <button class="search-btn" id="search-btn" disabled>ÿ¨ÿ≥ÿ™ÿ¨Ÿà</button>
                    <button class="search-drop-btn" id="copy-btn" type="button" title="⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß" disabled>‚ñæ</button>
                    <div class="copy-menu" id="copy-menu">
                        <div class="copy-menu-item" id="copy-results">
                            <span>ÿßŸÜÿ™ŸÇÿßŸÑ ÿ®Ÿá ÿ≠ÿßŸÅÿ∏Ÿá</span>
                            <span style="margin-right:auto; font-size:11px; color:#888;">ŸÜÿ™ÿß€åÿ¨ + ÿ™Ÿàÿ∂€åÿ≠ÿßÿ™</span>
                        </div>
                    </div>
                </div>
                <button class="search-btn embed-add-btn" id="embed-add-btn" type="button" title="ÿßŸÅÿ≤ŸàÿØŸÜ ÿß€åŸÜ ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿ®Ÿá ŸÑ€åÿ≥ÿ™ ÿßŸÜÿ™ÿÆÿßÿ®‚Äåÿ¥ÿØŸá" style="display: none;">ÿßŸÅÿ≤ŸàÿØŸÜ</button>
                <div class="settings-wrapper">
                    <button class="settings-btn" id="settings-btn" title="ÿ™ŸÜÿ∏€åŸÖÿßÿ™">‚öôÔ∏è</button>
                    <div class="settings-menu" id="settings-menu">
                        <div class="settings-title">ÿ™ŸÜÿ∏€åŸÖÿßÿ™</div>
                        <div class="settings-item">
                            <label>ŸÅŸàŸÜÿ™ ŸÇÿ±ÿ¢ŸÜ:</label>
                            <select id="font-select">
                                <option value="local">ŸÅŸàŸÜÿ™ ŸÇÿ±ÿ¢ŸÜ</option>
                                <option value="qurancom">ŸÅŸàŸÜÿ™ ÿπÿ´ŸÖÿßŸÜ ÿ∑Ÿá</option>
                                <option value="bbadr">ŸÅŸàŸÜÿ™ ÿ®ÿØÿ±</option>
                            </select>
                        </div>
                        <div class="settings-item">
                            <label>ŸÜŸÖÿß€åÿ¥ ŸÜÿ™ÿß€åÿ¨:</label>
                            <select id="view-mode-select">
                                <option value="paragraph">Ÿæÿßÿ±ÿß⁄Øÿ±ÿßŸÅ€å</option>
                                <option value="rows">Ÿáÿ± ÿ¢€åŸá €å⁄© ÿ≥ÿ∑ÿ± (ÿ¥ŸÖÿßÿ±Ÿá ÿßÿ®ÿ™ÿØÿß)</option>
                            </select>
                        </div>
                        <div class="settings-item">
                            <label>Ÿáÿß€åŸÑÿß€åÿ™:</label>
                            <select id="highlight-mode-select">
                                <option value="background">Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá</option>
                                <option value="text">ÿ±ŸÜ⁄Ø ŸÖÿ™ŸÜ</option>
                            </select>
                        </div>
                        <button class="apply-btn" id="apply-settings">ÿßÿπŸÖÿßŸÑ</button>
                        <a id="go-desktop-link" class="desktop-link" href="desktop.html" title="ÿ±ŸÅÿ™ŸÜ ÿ®Ÿá €åÿ≥€åÿ±">€åÿ≥€åÿ±</a>
                        <a id="go-simple-link" class="desktop-link" href="simple.html" title="ÿ±ŸÅÿ™ŸÜ ÿ®Ÿá ŸÜŸÖÿß€åÿ¥">ŸÜŸÖÿß€åÿ¥</a>
                    </div>
                </div>
            </div>
            
            <div class="selected-row">
                <div class="selected-items" id="selected-items">
                    <span class="empty-hint">ŸÖŸàÿ±ÿØ€å ÿßŸÜÿ™ÿÆÿßÿ® ŸÜÿ¥ÿØŸá. Ÿàÿß⁄òŸá €åÿß ÿ±€åÿ¥Ÿá‚Äåÿß€å ÿ±ÿß ÿ¨ÿ≥ÿ™ÿ¨Ÿà Ÿà ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.</span>
                </div>
                <button type="button" class="view-results-toggle" id="view-results-toggle" aria-pressed="false" title="ÿ≠ÿßŸÑÿ™ ŸÜŸÖÿß€åÿ¥ ŸÜÿ™ÿß€åÿ¨: ŸÖÿ™ŸÜ / ÿ¨ÿØŸàŸÑ / ŸÜŸÖŸàÿØÿßÿ±">
                    <span class="view-results-dot" aria-hidden="true"></span>
                    ŸÖÿ™ŸÜ
                </button>
                <span class="results-count num-hindi" id="results-count"></span>
            </div>
        </div>
        
        <div class="results-box" id="results-box" style="display: none;">
            <div class="results-content-column">
                <div id="results-content"></div>
            </div>
            <div class="items-panel" id="items-panel">
                <div id="items-panel-content"></div>
            </div>
        </div>
    </div>

    <script src="js/buckwalter.js"></script>
    <script src="js/sura-data.js"></script>
    <script src="js/search.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
    <script type="module">
    import { computePosition, offset, flip, shift, autoUpdate } from 'https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.6.10/+esm';
    (function() {
        'use strict';
        
        // Icons (centralized)
        const ITEM_ICONS = {
            // More meaningful than old üå±üìùüîç
            root: 'üå≥', // ÿ±€åÿ¥Ÿá
            word: 'üî†', // Ÿàÿß⁄òŸá
            text: 'üìù'  // ÿπÿ®ÿßÿ±ÿ™
        };

        // Data structures
        const morphologyData = {}; // {sura: {ayah: {wordIndex: {root, lemma, text}}}}
        const fmtFa = window.SearchShared.fmtFa;
        const normalizeDigitsToAscii = window.SearchShared.normalizeDigitsToAscii;
        const parseDistanceFromValue = window.SearchShared.parseDistanceFromValue;
        const normalizeArabic = window.SearchShared.normalizeArabic;
        function getDistanceValueClamped() {
            const el = document.getElementById('distance-input');
            const parsed = parseDistanceFromValue(el ? el.value : '');
            const v = Number.isFinite(parsed) ? parsed : 5;
            return Math.max(0, Math.min(100, v));
        }
        function setDistanceValueClamped(v) {
            const el = document.getElementById('distance-input');
            if (!el) return;
            const n = Number(v);
            const clamped = Number.isFinite(n) ? Math.max(0, Math.min(100, Math.trunc(n))) : 5;
            // Store Persian digits too, so selecting the input shows Persian.
            el.value = fmtFa(clamped);
        }

        const rootToWordsMap = {}; // {root: [{sura, ayah, wordIndex}, ...]}
        const wordTextsMap = {}; // {text: [{sura, ayah, wordIndex}, ...]}
        const ayahTexts = {}; // {sura: {ayah: "full text"}}
        let dataLoaded = false;
        
        // Selected search items
        const selectedItems = []; // [{type: 'text'|'root', value: string, checked: boolean}]
        
        // Item checked state (separate to preserve across re-renders)
        const itemCheckedState = []; // [boolean, ...] - tracks checked state for each selectedItem
        
        // LEM tracking for roots
        const rootLemData = {}; // {root: {lems: [{lem, count, selected}], allSelected: boolean}}
        const rootExpandedState = {}; // {root: boolean} - tracks if root LEMs are expanded
        let highlightedItem = null; // {type: 'item'|'lem', itemIndex, lem?} - for focus mode
        
        // Sura filter
        const selectedSuras = new Set(); // empty = all suras selected
        let allSurasSelected = true;
        
        // Get all LEMs for a root from morphology data (filtered by selected suras)
        function getLemsForRoot(root, filterBySura = true) {
            const lemCounts = {};
            const locations = rootToWordsMap[root] || [];
            
            for (const loc of locations) {
                // Filter by selected suras if requested
                if (filterBySura && !isSuraSelected(loc.sura)) continue;
                
                const wordData = morphologyData[loc.sura]?.[loc.ayah]?.[loc.wordIndex];
                if (wordData?.lemma) {
                    lemCounts[wordData.lemma] = (lemCounts[wordData.lemma] || 0) + 1;
                }
            }
            
            return Object.entries(lemCounts)
                .map(([lem, count]) => ({ lem, count, selected: true }))
                .sort((a, b) => b.count - a.count);
        }
        
        // Initialize LEM data for a root (preserves selection state on refresh)
        function initRootLemData(root, forceRefresh = false) {
            const newLems = getLemsForRoot(root);
            
            if (!rootLemData[root]) {
                rootLemData[root] = {
                    lems: newLems,
                    allSelected: true
                };
            } else if (forceRefresh) {
                // Preserve selection state
                const oldSelections = {};
                rootLemData[root].lems.forEach(l => { oldSelections[l.lem] = l.selected; });
                
                // Update with new counts, preserve selections
                rootLemData[root].lems = newLems.map(l => ({
                    ...l,
                    selected: oldSelections[l.lem] !== undefined ? oldSelections[l.lem] : true
                }));
            }
            return rootLemData[root];
        }
        
        // Build items panel HTML
        function buildItemsPanel() {
            const container = document.getElementById('items-panel-content');
            if (!container) return;
            
            // Ensure itemCheckedState has entries for all items (default to true)
            while (itemCheckedState.length < selectedItems.length) {
                itemCheckedState.push(true);
            }
            
            const icons = ITEM_ICONS;
            const typeLabels = { text: 'ÿπÿ®ÿßÿ±ÿ™', word: 'Ÿàÿß⁄òŸá', root: 'ÿ±€åÿ¥Ÿá' };
            let html = '';
            
            selectedItems.forEach((item, index) => {
                const colorIndex = index % 8;
                const isHighlighted = highlightedItem?.type === 'item' && highlightedItem?.itemIndex === index;
                const isChecked = itemCheckedState[index] !== false;
                const isRoot = item.type === 'root';
                const isExpanded = isRoot ? (rootExpandedState[item.value] !== false) : false;
                
                html += `<div class="search-item-row ${isHighlighted ? 'highlighted' : ''} ${!isChecked ? 'unchecked' : ''}" 
                              data-item-index="${index}" data-item-type="${item.type}" data-root="${item.value || ''}">
                    <input type="checkbox" class="item-checkbox" ${isChecked ? 'checked' : ''} 
                           onclick="event.stopPropagation()">`;
                
                // Add expand/collapse toggle for roots, or spacer for non-roots
                if (isRoot) {
                    html += `<span class="expand-toggle ${!isExpanded ? 'collapsed' : ''}" 
                                   onclick="event.stopPropagation()">‚ñº</span>`;
                } else {
                    html += `<span class="expand-spacer"></span>`;
                }
                
                html += `<span class="item-color" style="background: var(--color-${colorIndex})"></span>
                    <span class="item-label">${icons[item.type]} ${item.display || item.value}</span>
                    <span class="item-type">${typeLabels[item.type]}</span>
                </div>`;
                
                // If root, show LEMs in collapsible container
                if (isRoot) {
                    const lemData = initRootLemData(item.value, true); // true = refresh counts for current sura filter
                    html += `<div class="lems-container ${!isExpanded ? 'collapsed' : ''}" data-root="${item.value}">`;
                    lemData.lems.forEach((lemInfo, lemIndex) => {
                        const isLemHighlighted = highlightedItem?.type === 'lem' && 
                                                  highlightedItem?.itemIndex === index && 
                                                  highlightedItem?.lem === lemInfo.lem;
                        html += `<div class="lem-subrow ${isLemHighlighted ? 'highlighted' : ''} ${!lemInfo.selected ? 'unchecked' : ''}"
                                      data-item-index="${index}" data-lem="${lemInfo.lem}" data-lem-index="${lemIndex}">
                            <input type="checkbox" ${lemInfo.selected ? 'checked' : ''} 
                                   onclick="event.stopPropagation()">
                            <span class="lem-label">${lemInfo.lem}</span>
                            <span class="lem-count num-hindi">${fmtFa(lemInfo.count)}</span>
                        </div>`;
                    });
                    html += `</div>`;
                }
            });
            
            container.innerHTML = html;
            
            // Bind click events for highlighting
            container.querySelectorAll('.search-item-row').forEach(row => {
                row.addEventListener('click', (e) => {
                    if (e.target.type !== 'checkbox' && !e.target.classList.contains('expand-toggle')) {
                        handleItemClick(row);
                    }
                });
                row.querySelector('.item-checkbox').addEventListener('change', (e) => {
                    handleItemCheckbox(row, e.target.checked);
                });
                
                // Expand/collapse toggle for roots
                const toggle = row.querySelector('.expand-toggle');
                if (toggle) {
                    toggle.addEventListener('click', () => {
                        const root = row.dataset.root;
                        // Current state: undefined or true = expanded, false = collapsed
                        const currentlyExpanded = rootExpandedState[root] !== false;
                        rootExpandedState[root] = !currentlyExpanded;
                        buildItemsPanel();
                    });
                }
            });
            
            container.querySelectorAll('.lem-subrow').forEach(row => {
                row.addEventListener('click', (e) => {
                    if (e.target.type !== 'checkbox') {
                        handleLemClick(row);
                    }
                });
                row.querySelector('input[type="checkbox"]').addEventListener('change', (e) => {
                    handleLemCheckbox(row, e.target.checked);
                });
            });
        }
        
        // Handle clicking on a search item row
        function handleItemClick(row) {
            const itemIndex = parseInt(row.dataset.itemIndex);
            
            // Toggle highlight
            if (highlightedItem?.type === 'item' && highlightedItem?.itemIndex === itemIndex) {
                highlightedItem = null;
            } else {
                highlightedItem = { type: 'item', itemIndex };
            }
            
            buildItemsPanel();
            requestAutoSearch(0);
        }
        
        // Handle clicking on a LEM row
        function handleLemClick(row) {
            const itemIndex = parseInt(row.dataset.itemIndex);
            const lem = row.dataset.lem;
            
            // Toggle highlight
            if (highlightedItem?.type === 'lem' && highlightedItem?.itemIndex === itemIndex && highlightedItem?.lem === lem) {
                highlightedItem = null;
            } else {
                highlightedItem = { type: 'lem', itemIndex, lem };
            }
            
            buildItemsPanel();
            requestAutoSearch(0);
        }
        
        // Handle LEM checkbox change
        function handleLemCheckbox(row, checked) {
            const itemIndex = parseInt(row.dataset.itemIndex);
            const lemIndex = parseInt(row.dataset.lemIndex);
            const root = selectedItems[itemIndex].value;
            
            if (rootLemData[root]) {
                rootLemData[root].lems[lemIndex].selected = checked;
            }
            
            buildItemsPanel();
            requestAutoSearch(0);
        }
        
        // Handle item checkbox change
        function handleItemCheckbox(row, checked) {
            const itemIndex = parseInt(row.dataset.itemIndex);
            itemCheckedState[itemIndex] = checked;
            
            buildItemsPanel();
            requestAutoSearch(0);
        }
        
        function isAutoUpdateEnabled() {
            const cb = document.getElementById('auto-update');
            // If the control isn't present, default to ON.
            return !cb || cb.checked;
        }

        let __autoUpdateTimer = null;
        function requestAutoSearch(delayMs = 120) {
            if (!isAutoUpdateEnabled()) return;
            if (selectedItems.length === 0) return;
            if (__autoUpdateTimer) clearTimeout(__autoUpdateTimer);
            // Run heavy work in rAF so the setTimeout handler returns quickly and avoids
            // "[Violation] 'setTimeout' handler took Xms" (Chrome flags handlers > ~50ms).
            __autoUpdateTimer = setTimeout(() => {
                __autoUpdateTimer = null;
                if (!isAutoUpdateEnabled()) return;
                if (selectedItems.length === 0) return;
                requestAnimationFrame(() => { triggerSearch(); });
            }, Math.max(0, delayMs | 0));
        }

        // Trigger search with current settings (serialized to avoid overlapping renders)
        let __searchInFlight = null;
        let __searchQueued = false;
        async function triggerSearch() {
            if (__searchInFlight) {
                __searchQueued = true;
                return __searchInFlight;
            }
            __searchInFlight = (async () => {
                const results = performSearch();
                await renderResults(results);
            })();
            try {
                return await __searchInFlight;
            } finally {
                __searchInFlight = null;
                if (__searchQueued) {
                    __searchQueued = false;
                    triggerSearch();
                }
            }
        }
        
        // QCF (Quran Complex Font) data from quran.com
        const qcfWordData = {}; // {sura: {ayah: {wordIndex: {page, code_v1}}}}
        const loadedQCFPages = new Set();
        let qcfDataLoaded = {};
        
        // SURA_NAMES loaded from js/sura-data.js
        // Buckwalter conversion loaded from js/buckwalter.js
        
        // Load QCF word data from quran.com API for a sura
        async function loadQCFDataForSura(sura) {
            if (qcfDataLoaded[sura]) return;
            
            try {
                const response = await fetch(`https://api.quran.com/api/v4/verses/by_chapter/${sura}?words=true&word_fields=v1_page,code_v1&per_page=300`);
                const data = await response.json();
                
                if (!qcfWordData[sura]) qcfWordData[sura] = {};
                
                for (const verse of data.verses) {
                    const ayah = verse.verse_number;
                    if (!qcfWordData[sura][ayah]) qcfWordData[sura][ayah] = {};
                    
                    let wordIndex = 1;
                    for (const word of verse.words) {
                        // Skip end markers (like verse numbers)
                        if (word.char_type_name === 'end') continue;
                        
                        qcfWordData[sura][ayah][wordIndex] = {
                            page: word.v1_page,
                            code: word.code_v1
                        };
                        wordIndex++;
                    }
                }
                
                qcfDataLoaded[sura] = true;
            } catch (error) {
                console.error(`Error loading QCF data for sura ${sura}:`, error);
            }
        }
        
        // Load QCF page font
        function loadQCFPageFont(page) {
            if (loadedQCFPages.has(page)) return;
            loadedQCFPages.add(page);
            
            const paddedPage = String(page).padStart(3, '0');
            const style = document.createElement('style');
            style.textContent = `
                @font-face {
                    font-family: 'QCF_P${paddedPage}';
                    src: url('https://static.qurancdn.com/fonts/quran/hafs/v1/woff2/p${page}.woff2') format('woff2'),
                         url('https://static.qurancdn.com/fonts/quran/hafs/v1/woff/p${page}.woff') format('woff');
                    size-adjust: 120%;
                    font-display: swap;
                }
            `;
            document.head.appendChild(style);
        }
        
        // Get QCF word HTML
        function getQCFWordHTML(sura, ayah, wordIndex, highlightClass = '') {
            const wordData = qcfWordData[sura]?.[ayah]?.[wordIndex];
            if (!wordData) {
                // Fallback to normal text
                const text = morphologyData[sura]?.[ayah]?.[wordIndex]?.text || '';
                return highlightClass ? `<span class="${highlightClass}">${text}</span>` : text;
            }
            
            // Load the page font if not loaded
            loadQCFPageFont(wordData.page);
            
            const paddedPage = String(wordData.page).padStart(3, '0');
            const classes = `qcf-word${highlightClass ? ' ' + highlightClass : ''}`;
            return `<span class="${classes}" style="font-family: 'QCF_P${paddedPage}', serif;">${wordData.code}</span>`;
        }
        
        // Load morphology data
        async function loadMorphologyData() {
            try {
                const response = await fetch('data/quranic-corpus-morphology-0.4.txt');
                const text = await response.text();
                parseMorphologyData(text);
                dataLoaded = true;
                document.getElementById('search-input').placeholder = 'Ÿàÿß⁄òŸá €åÿß ÿ±€åÿ¥Ÿá ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ...';
            } catch (error) {
                console.error('Error loading morphology data:', error);
                document.getElementById('search-input').placeholder = 'ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿØÿßÿØŸá‚ÄåŸáÿß';
            }
        }
        
        function parseMorphologyData(text) {
            statsUniverseCache = null;
            const lines = text.split('\n');
            
            // First pass: collect all segments for each word
            const wordSegments = {}; // key: "sura:ayah:word" -> [{segment, text, features}, ...]
            
            for (const line of lines) {
                if (!line || line.startsWith('#') || line.startsWith('LOCATION')) continue;
                
                const parts = line.split('\t');
                if (parts.length < 3) continue;
                
                const location = parts[0];
                const wordText = parts[1];
                const features = parts[3] || '';
                
                // Parse location (sura:ayah:word:segment)
                const locMatch = location.match(/\((\d+):(\d+):(\d+):(\d+)\)/);
                if (!locMatch) continue;
                
                const sura = parseInt(locMatch[1]);
                const ayah = parseInt(locMatch[2]);
                const wordIndex = parseInt(locMatch[3]);
                const segment = parseInt(locMatch[4]);
                
                const key = `${sura}:${ayah}:${wordIndex}`;
                if (!wordSegments[key]) {
                    wordSegments[key] = { sura, ayah, wordIndex, segments: [] };
                }
                wordSegments[key].segments.push({ segment, text: wordText, features });
            }
            
            // Second pass: combine segments and build data structures
            for (const key in wordSegments) {
                const { sura, ayah, wordIndex, segments } = wordSegments[key];
                
                // Sort segments by segment number
                segments.sort((a, b) => a.segment - b.segment);
                
                // Combine all segment texts to form the full word
                const fullWordBuckwalter = segments.map(s => s.text).join('');
                const arabicWord = convertBuckwalterToArabic(fullWordBuckwalter);
                
                // Find root from any segment (usually in STEM segment)
                let root = null;
                let lemma = null;
                for (const seg of segments) {
                    if (!root) {
                        const rootMatch = seg.features.match(/ROOT:([A-Za-z'><&}{\-]+)/);
                        if (rootMatch) root = convertBuckwalterToArabic(rootMatch[1]);
                    }
                    if (!lemma) {
                        const lemmaMatch = seg.features.match(/LEM:([^\|]+)/);
                        if (lemmaMatch) lemma = convertBuckwalterToArabic(lemmaMatch[1]);
                    }
                }
                
                // Store in morphologyData
                if (!morphologyData[sura]) morphologyData[sura] = {};
                if (!morphologyData[sura][ayah]) morphologyData[sura][ayah] = {};
                morphologyData[sura][ayah][wordIndex] = { root, lemma, text: arabicWord };
                
                // Build root-to-words map
                if (root) {
                    if (!rootToWordsMap[root]) rootToWordsMap[root] = [];
                    // Avoid duplicates
                    const exists = rootToWordsMap[root].some(
                        w => w.sura === sura && w.ayah === ayah && w.wordIndex === wordIndex
                    );
                    if (!exists) {
                        rootToWordsMap[root].push({ sura, ayah, wordIndex });
                    }
                }
                
                // Build word texts map (normalized - remove diacritics for search)
                const normalizedWord = normalizeArabic(arabicWord);
                if (normalizedWord.length > 1) {
                    if (!wordTextsMap[normalizedWord]) wordTextsMap[normalizedWord] = [];
                    wordTextsMap[normalizedWord].push({ sura, ayah, wordIndex, original: arabicWord });
                }
            }
        }
        
        // Search suggestions
        function getSuggestions(query) {
            if (!query || query.length < 2 || !dataLoaded) return [];
            
            const normalizedQuery = normalizeArabic(query);
            const rootSuggestions = [];
            const wordSuggestions = [];
            const textSuggestions = [];
            
            // Helper to get sample words for a root
            function getSampleWordsForRoot(root, limit = 5) {
                const words = new Set();
                const locations = rootToWordsMap[root] || [];
                for (const loc of locations) {
                    const wordData = morphologyData[loc.sura]?.[loc.ayah]?.[loc.wordIndex];
                    if (wordData?.text) {
                        words.add(wordData.text);
                        if (words.size >= limit) break;
                    }
                }
                return [...words];
            }
            
            // Helper to count unique words for a root
            function countUniqueWordsForRoot(root) {
                const words = new Set();
                const locations = rootToWordsMap[root] || [];
                for (const loc of locations) {
                    const wordData = morphologyData[loc.sura]?.[loc.ayah]?.[loc.wordIndex];
                    if (wordData?.text) {
                        words.add(wordData.text);
                    }
                }
                return words.size;
            }
            
            // 1. Search matching words and collect their roots
            const matchingWords = Object.entries(wordTextsMap)
                .filter(([word]) => word.includes(normalizedQuery))
                .sort((a, b) => b[1].length - a[1].length) // Sort by frequency
                .slice(0, 8);
            
            // Collect roots from matched words with their sample words
            const rootsFromWords = new Map(); // root -> Set of sample words
            
            matchingWords.forEach(([word, locations]) => {
                // Get original (with diacritics) from first occurrence
                const originalWord = locations[0]?.original || word;
                
                // Find the root for this word
                const loc = locations[0];
                const wordRoot = morphologyData[loc.sura]?.[loc.ayah]?.[loc.wordIndex]?.root;
                if (wordRoot) {
                    if (!rootsFromWords.has(wordRoot)) {
                        rootsFromWords.set(wordRoot, new Set());
                    }
                    rootsFromWords.get(wordRoot).add(originalWord);
                }
                
                wordSuggestions.push({
                    type: 'word',
                    value: word,
                    display: originalWord,
                    count: locations.length,
                    icon: ITEM_ICONS.word
                });
            });
            
            // 2. Build root suggestions (roots from matched words first, then directly matching)
            const addedRoots = new Set();
            
            // Roots from matched words
            rootsFromWords.forEach((sampleWords, root) => {
                if (rootToWordsMap[root]) {
                    // Get more sample words from root if needed
                    const allSamples = new Set(sampleWords);
                    if (allSamples.size < 5) {
                        const moreSamples = getSampleWordsForRoot(root, 5);
                        moreSamples.forEach(w => allSamples.add(w));
                    }
                    const samplesArray = [...allSamples].slice(0, 5);
                    const totalUniqueWords = countUniqueWordsForRoot(root);
                    const ellipsis = totalUniqueWords > 5 ? 'ÿå ...' : '';
                    const displayWithSamples = `${root} (${samplesArray.join('ÿå ')}${ellipsis})`;
                    
                    rootSuggestions.push({
                        type: 'root',
                        value: root,
                        display: displayWithSamples,
                        count: rootToWordsMap[root].length,
                        icon: ITEM_ICONS.root
                    });
                    addedRoots.add(root);
                }
            });
            
            // Directly matching roots
            const matchingRoots = Object.keys(rootToWordsMap)
                .filter(root => !addedRoots.has(root) && (root.includes(query) || normalizeArabic(root).includes(normalizedQuery)))
                .sort((a, b) => rootToWordsMap[b].length - rootToWordsMap[a].length)
                .slice(0, 8);
            
            matchingRoots.forEach(root => {
                const samples = getSampleWordsForRoot(root, 5);
                const totalUniqueWords = countUniqueWordsForRoot(root);
                const ellipsis = totalUniqueWords > 5 ? 'ÿå ...' : '';
                const displayWithSamples = samples.length > 0 ? `${root} (${samples.join('ÿå ')}${ellipsis})` : root;
                
                rootSuggestions.push({
                    type: 'root',
                    value: root,
                    display: displayWithSamples,
                    count: rootToWordsMap[root].length,
                    icon: ITEM_ICONS.root
                });
            });
            
            // 3. Add text search option (partial match in any word)
            const textCount = countTextMatches(normalizedQuery);
            if (textCount > 0) {
                textSuggestions.push({
                    type: 'text',
                    value: query,
                    display: `"${query}"`,
                    count: textCount,
                    icon: ITEM_ICONS.text
                });
            }
            
            // Return in order: roots, words, text
            return [...rootSuggestions, ...wordSuggestions, ...textSuggestions];
        }
        
        function countTextMatches(normalizedText) {
            // Check if multi-word phrase
            const words = normalizedText.trim().split(/\s+/);
            if (words.length > 1) {
                return countPhraseMatches(words);
            }
            
            // Single word - partial match
            let count = 0;
            for (const [word, locations] of Object.entries(wordTextsMap)) {
                if (word.includes(normalizedText)) {
                    count += locations.length;
                }
            }
            return count;
        }
        
        // Count multi-word phrase matches
        function countPhraseMatches(normalizedWords) {
            let count = 0;
            
            // Search through all ayahs
            for (const sura in morphologyData) {
                for (const ayah in morphologyData[sura]) {
                    const ayahData = morphologyData[sura][ayah];
                    const wordIndices = Object.keys(ayahData).map(Number).sort((a, b) => a - b);
                    
                    // Check each starting position
                    for (let i = 0; i <= wordIndices.length - normalizedWords.length; i++) {
                        let matches = true;
                        for (let j = 0; j < normalizedWords.length; j++) {
                            const wordIndex = wordIndices[i + j];
                            const wordData = ayahData[wordIndex];
                            const normalizedWord = normalizeArabic(wordData?.text || '');
                            if (!normalizedWord.includes(normalizedWords[j])) {
                                matches = false;
                                break;
                            }
                        }
                        if (matches) count++;
                    }
                }
            }
            return count;
        }
        
        // Check if sura is in the selected filter
        function isSuraSelected(sura) {
            if (allSurasSelected) return true;
            if (selectedSuras.size === 0) return false; // None selected
            return selectedSuras.has(sura);
        }

        function findPhraseOccurrences(normalizedWords) {
            const occurrences = [];
            for (const sura in morphologyData) {
                const suraNum = parseInt(sura, 10);
                if (!isSuraSelected(suraNum)) continue;
                for (const ayah in morphologyData[sura]) {
                    const ayahNum = parseInt(ayah, 10);
                    const ayahData = morphologyData[sura][ayah];
                    const wordIndices = Object.keys(ayahData).map(Number).sort((a, b) => a - b);
                    for (let i = 0; i <= wordIndices.length - normalizedWords.length; i++) {
                        let phraseMatches = true;
                        for (let j = 0; j < normalizedWords.length; j++) {
                            const wordIndex = wordIndices[i + j];
                            const wordData = ayahData[wordIndex];
                            const normalizedWord = normalizeArabic(wordData?.text || '');
                            if (!normalizedWord.includes(normalizedWords[j])) {
                                phraseMatches = false;
                                break;
                            }
                        }
                        if (phraseMatches) {
                            occurrences.push({
                                sura: suraNum,
                                ayah: ayahNum,
                                startWordIndex: wordIndices[i],
                                wordCount: normalizedWords.length,
                                matchType: 'text'
                            });
                        }
                    }
                }
            }
            return occurrences;
        }
        
        // Find phrase matches (returns starting positions)
        function findPhraseMatches(normalizedWords) {
            const matches = [];
            const occurrences = findPhraseOccurrences(normalizedWords);
            for (let i = 0; i < occurrences.length; i++) {
                const occ = occurrences[i];
                for (let offset = 0; offset < occ.wordCount; offset++) {
                    matches.push({
                        sura: occ.sura,
                        ayah: occ.ayah,
                        wordIndex: occ.startWordIndex + offset,
                        matchType: 'text',
                        phraseOccurrence: i
                    });
                }
            }
            return matches;
        }
        
        // Find words matching an item
        // Find all matches for a search item, respecting LEM selection
        // focusedLem: specific LEM to search (ignore others)
        // ignoreFilters: if true, ignore LEM checkboxes (used when root item is highlighted)
        function findMatchingWords(item, itemIndex = -1, focusedLem = null, ignoreFilters = false) {
            const matches = [];
            const normalized = normalizeArabic(item.value || '');
            
            if (item.type === 'root') {
                const words = rootToWordsMap[item.value] || [];
                const lemData = rootLemData[item.value];
                
                // Get selected LEMs (or just the focused one)
                let allowedLems = null;
                if (focusedLem) {
                    // Specific LEM is focused - only that one
                    allowedLems = new Set([focusedLem]);
                } else if (!ignoreFilters && lemData) {
                    // Normal mode - filter by checked LEMs
                    allowedLems = new Set(lemData.lems.filter(l => l.selected).map(l => l.lem));
                }
                // If ignoreFilters is true, allowedLems stays null (all LEMs allowed)
                
                words.forEach(w => {
                    // Filter by sura
                    if (!isSuraSelected(w.sura)) return;
                    
                    const wordData = morphologyData[w.sura]?.[w.ayah]?.[w.wordIndex];
                    const wordLem = wordData?.lemma;
                    
                    // Filter by allowed LEMs if specified
                    if (allowedLems && wordLem && !allowedLems.has(wordLem)) {
                        return;
                    }
                    
                    matches.push({ ...w, matchType: 'root' });
                });
            } else if (item.type === 'word') {
                // Exact word match
                const locations = wordTextsMap[item.value] || [];
                locations.forEach(loc => {
                    if (isSuraSelected(loc.sura)) {
                        matches.push({ ...loc, matchType: 'word' });
                    }
                });
            } else {
                // Text search (partial match or phrase)
                const normalizedQuery = normalizeArabic(item.value);
                const words = normalizedQuery.trim().split(/\s+/);
                
                if (words.length > 1) {
                    // Multi-word phrase search
                    return findPhraseMatches(words);
                }
                
                // Single word partial match
                for (const [word, locations] of Object.entries(wordTextsMap)) {
                    if (word.includes(normalizedQuery)) {
                        locations.forEach(loc => {
                            if (isSuraSelected(loc.sura)) {
                                matches.push({ ...loc, matchType: 'text' });
                            }
                        });
                    }
                }
            }
            
            return matches;
        }
        
        // Calculate global ayah position for a match.
        // Position is cumulative ayah count from start of Quran.
        let globalAyahCache = null;
        function buildGlobalAyahCache() {
            if (globalAyahCache) return globalAyahCache;
            const suraAyahToPos = {};
            const posToSuraAyah = [];
            let cumulative = 0;

            const suraMaxPos = {};
            for (let sura = 1; sura <= 114; sura++) {
                suraAyahToPos[sura] = {};
                const suraData = morphologyData[sura];
                if (!suraData) continue;

                const ayahs = Object.keys(suraData).map(Number).sort((a, b) => a - b);
                for (const ayah of ayahs) {
                    suraAyahToPos[sura][ayah] = cumulative;
                    posToSuraAyah[cumulative] = { sura, ayah };
                    cumulative++;
                }
                suraMaxPos[sura] = cumulative - 1;
            }
            globalAyahCache = { suraAyahToPos, posToSuraAyah, suraMaxPos };
            return globalAyahCache;
        }

        function getGlobalAyahPosition(match) {
            const cache = buildGlobalAyahCache();
            return cache.suraAyahToPos[match.sura]?.[match.ayah] ?? 0;
        }

        function getSuraAyahFromPosition(pos) {
            const cache = buildGlobalAyahCache();
            return cache.posToSuraAyah[pos] || { sura: 0, ayah: 0 };
        }

        function suraMaxPos(sura) {
            const cache = buildGlobalAyahCache();
            return cache.suraMaxPos[sura] ?? 0;
        }
        
        // Calculate distance between two matches in absolute/global ayah index.
        // NOTE: crossSura is intentionally ignored now; all matching logic uses global distance.
        function calculateDistance(a, b, crossSura) {
            const posA = getGlobalAyahPosition(a);
            const posB = getGlobalAyahPosition(b);
            return Math.abs(posB - posA);
        }
        
        // Get global position for sorting/intervals (still use ayah-based)
        function getGlobalPosition(match) {
            return getGlobalAyahPosition(match);
        }
        
        // Compare two positions (for sorting)
        function comparePositions(a, b) {
            if (a.sura !== b.sura) return a.sura - b.sura;
            if (a.ayah !== b.ayah) return a.ayah - b.ayah;
            return a.wordIndex - b.wordIndex;
        }
        
        // Search algorithm as specified by user
        // Output: array of grouped regions, plus attached combined stats metadata:
        //   __combinedCSBySura, __combinedStartAyahsBySura, __combinedStartDebug, __combinedTotalCS
        function performSearch() {
            if (selectedItems.length === 0) return [];
            
            const distance = getDistanceValueClamped(); // max allowed ayah distance window
            const crossSura = document.getElementById('cross-sura-toggle')?.getAttribute('aria-pressed') === 'true'; // if true, distance can cross sura boundaries
            
            // Check if we're in focus mode (single item/lem highlighted)
            if (highlightedItem) {
                const itemIndex = highlightedItem.itemIndex;
                const item = selectedItems[itemIndex];
                
                let focusedLem = null;
                let ignoreFilters = false;
                
                if (highlightedItem.type === 'lem') {
                    // Specific LEM highlighted - search only that LEM
                    focusedLem = highlightedItem.lem;
                } else if (highlightedItem.type === 'item') {
                    // Entire item highlighted - ignore LEM filters, search all
                    ignoreFilters = true;
                }
                
                const matches = findMatchingWords(item, itemIndex, focusedLem, ignoreFilters);
                matches.forEach(m => m.itemIndex = itemIndex);
                const groups = groupMatchesByRegion(matches.sort(comparePositions), crossSura);
                groups.__combinedCSBySura = {};
                groups.__combinedStartAyahsBySura = {};
                groups.__combinedStartDebug = [];
                groups.__combinedTotalCS = 0;
                groups.__combinedEligible = false;
                groups.__statsInput = { sections: [{ item, itemIndex, matches, focusedLem }] };
                return groups;
            }
            
            // Filter to only checked items
            const checkedIndices = selectedItems // indices of active (checked) search items
                .map((_, idx) => idx)
                .filter(idx => itemCheckedState[idx] !== false);
            
            if (checkedIndices.length === 0) {
                const groups = [];
                groups.__combinedCSBySura = {};
                groups.__combinedStartAyahsBySura = {};
                groups.__combinedStartDebug = [];
                groups.__combinedTotalCS = 0;
                groups.__combinedEligible = false;
                return groups;
            }
            
            const n = checkedIndices.length; // number of active search items
            
            // Step 1: Get matches and M[i] = sorted unique absolute ayah positions per item
            const matchesByItem = checkedIndices.map(itemIndex => {
                const item = selectedItems[itemIndex];
                const matches = findMatchingWords(item, itemIndex);
                matches.forEach(m => m.itemIndex = itemIndex);
                return matches.sort(comparePositions);
            });
            const M = matchesByItem.map(matches => {
                const seen = new Set();
                for (const m of matches) seen.add(getGlobalAyahPosition(m));
                return Array.from(seen).sort((a, b) => a - b);
            });
            // startCandidates = unique positions from all M[i]
            const startCandidates = [...new Set(M.flat())].sort((a, b) => a - b);

            if (n === 1) {
                const groups = groupMatchesByRegion(matchesByItem[0], crossSura);
                groups.__combinedCSBySura = {};
                groups.__combinedStartAyahsBySura = {};
                groups.__combinedStartDebug = [];
                groups.__combinedTotalCS = 0;
                groups.__combinedEligible = false;
                groups.__statsInput = {
                    sections: checkedIndices.map((itemIndex, i) => ({
                        item: selectedItems[itemIndex],
                        itemIndex,
                        matches: matchesByItem[i],
                        focusedLem: null
                    }))
                };
                return groups;
            }
            
            // Step 2: For each match M[i][j], compute matchingSets[i][j][i2]
            // matchingSets[i][j][i2] = farthest matching item of set i2 that is after M[i][j] within distance
            
            const intervals = [];
            const combinedStartAyahBySura = {}; // {sura -> set of start ayahs}
            const combinedStartDebug = [];

            function hasAnyInRange(sortedArr, lo, hi) {
                if (!sortedArr || sortedArr.length === 0) return false;
                let l = 0, r = sortedArr.length - 1, first = sortedArr.length;
                while (l <= r) {
                    const mid = (l + r) >> 1;
                    if (sortedArr[mid] >= lo) { first = mid; r = mid - 1; }
                    else l = mid + 1;
                }
                return first < sortedArr.length && sortedArr[first] <= hi;
            }

            function collectInRange(arr, lo, hi, getPos = x => x) {
                if (!arr || arr.length === 0) return [];
                let l = 0, r = arr.length - 1, first = arr.length;
                while (l <= r) {
                    const mid = (l + r) >> 1;
                    if (getPos(arr[mid]) >= lo) { first = mid; r = mid - 1; }
                    else l = mid + 1;
                }
                const out = [];
                for (let i = first; i < arr.length && getPos(arr[i]) <= hi; i++) out.push(arr[i]);
                return out;
            }

            for (let ci = 0; ci < startCandidates.length; ci++) {
                const cPos = startCandidates[ci];
                let ok = true;
                for (let ii = 0; ii < M.length; ii++) {
                    const cPosSA = getSuraAyahFromPosition(cPos);
                    const maxPos = crossSura ? 1e5 : suraMaxPos(cPosSA.sura); // 1e5 is just a big number to ensure we don't exceed the sura boundary
                    const found = hasAnyInRange(M[ii], cPos, Math.min(cPos + distance, maxPos));
                    if (!found) { ok = false; break; }
                    // const inRangeValues = collectInRange(M[ii], cPos, Math.min(cPos + distance, maxPos))
                    //     .map(p => { const s = getSuraAyahFromPosition(p); return `${s.sura}:${s.ayah}`; });
                    // matchedByItem.push({ // only used for debugging
                    //     itemIndex: checkedIndices[ii],
                    //     item: selectedItems[checkedIndices[ii]] ? `${selectedItems[checkedIndices[ii]].type}:${selectedItems[checkedIndices[ii]].value}` : `item:${checkedIndices[ii]}`,
                    //     inRange: inRangeValues
                    // });
                }
                if (ok) {
                    const { sura, ayah } = getSuraAyahFromPosition(cPos);
                    if (!combinedStartAyahBySura[sura]) combinedStartAyahBySura[sura] = new Set();
                    combinedStartAyahBySura[sura].add(ayah);

                    const maxPos = crossSura ? 1e5 : suraMaxPos(sura);
                    const hi = Math.min(cPos + distance, maxPos);

                    const matchedByItem = [];
                    const allMatches = [];
                    for (let ii = 0; ii < n; ii++) {
                        const matchesInRange = collectInRange(matchesByItem[ii], cPos, hi, getGlobalPosition);
                        allMatches.push(...matchesInRange);
                        const inRangeValues = [...new Set(matchesInRange.map(m => `${m.sura}:${m.ayah}`))];
                        matchedByItem.push({
                            itemIndex: checkedIndices[ii],
                            item: selectedItems[checkedIndices[ii]] ? `${selectedItems[checkedIndices[ii]].type}:${selectedItems[checkedIndices[ii]].value}` : `item:${checkedIndices[ii]}`,
                            inRange: inRangeValues
                        });
                    }
                    combinedStartDebug.push({ start: { sura, ayah }, matchedByItem });

                    const positions = allMatches.map(m => getGlobalPosition(m));
                    intervals.push({
                        startPos: Math.min(...positions),
                        endPos: Math.max(...positions),
                        matches: allMatches
                    });
                }
            }
            
            // Step 4: Sort intervals by starting point
            intervals.sort((a, b) => a.startPos - b.startPos);
            
            // Step 5: Merge overlapping intervals
            const mergedIntervals = [];
            for (const interval of intervals) {
                if (mergedIntervals.length === 0) {
                    mergedIntervals.push(interval);
                } else {
                    const last = mergedIntervals[mergedIntervals.length - 1];
                    // Check if intervals overlap or are adjacent
                    if (interval.startPos <= last.endPos + 1) {
                        // Merge
                        last.endPos = Math.max(last.endPos, interval.endPos);
                        // Add matches avoiding duplicates
                        for (const m of interval.matches) {
                            const exists = last.matches.some(
                                lm => lm.sura === m.sura && lm.ayah === m.ayah && lm.wordIndex === m.wordIndex
                            );
                            if (!exists) {
                                last.matches.push(m);
                            }
                        }
                    } else {
                        mergedIntervals.push(interval);
                    }
                }
            }
            
            // Step 6: Convert intervals to result format (groups with sura, startAyah, endAyah)
            const groups = convertIntervalsToGroups(mergedIntervals, crossSura);
            const csBySura = {}; // {sura -> c_s}
            const startsBySura = {}; // {sura -> sorted start ayahs used for c_s}
            let totalCS = 0;
            for (const k of Object.keys(combinedStartAyahBySura)) {
                const starts = Array.from(combinedStartAyahBySura[k]).sort((a, b) => a - b);
                startsBySura[k] = starts;
                const c = starts.length;
                csBySura[k] = c;
                totalCS += c;
            }
            // console.log('startsBySura:', startsBySura[2]);
            groups.__combinedCSBySura = csBySura;
            groups.__combinedStartAyahsBySura = startsBySura;
            groups.__combinedStartDebug = combinedStartDebug;
            groups.__combinedTotalCS = totalCS;
            groups.__combinedEligible = true;
            groups.__statsInput = {
                sections: checkedIndices.map((itemIndex, i) => ({
                    item: selectedItems[itemIndex],
                    itemIndex,
                    matches: matchesByItem[i],
                    focusedLem: null
                }))
            };
            return groups;
        }

        const urlParams = new URLSearchParams(window.location.search);
        const isEmbedMode = urlParams.get('embed') === '1';
        const SEARCH_RESULTS_VIEW_STORAGE_KEY = isEmbedMode
            ? 'searchResultsView:embed'
            : 'searchResultsView:standalone';

        const STATS_ALPHA = window.SearchShared.STATS_ALPHA;
        let statsUniverseCache = null;
        let searchResultsView = localStorage.getItem(SEARCH_RESULTS_VIEW_STORAGE_KEY) || 'regions';
        let statsMatchMode = localStorage.getItem('searchStatsMatchMode') || 'any';
        let statsSortKey = localStorage.getItem('searchStatsSortKey') || 'sura';
        let statsSortDir = localStorage.getItem('searchStatsSortDir') || 'asc';
        let lastRenderedStats = [];
        let lastCombinedSearchMeta = { bySura: {}, startsBySura: {}, startDebug: [], totalCS: 0, eligible: false };

        function ensureStatsUniverseCache() {
            if (statsUniverseCache) return statsUniverseCache;
            statsUniverseCache = window.SearchShared.buildStatsUniverseCache(morphologyData);
            return statsUniverseCache;
        }

        function resolveStatsUniverse(itemType) {
            const cache = ensureStatsUniverseCache();
            const scope = allSurasSelected ? null : Array.from(selectedSuras);
            return window.SearchShared.resolveStatsUniverseScoped(cache, itemType, scope, { source: 'search.html' });
        }

        function computePerSuraMetrics(cSura, cAll, NSura, totalTokens, vocabularySize) {
            return window.SearchShared.computePerSuraMetrics(cSura, cAll, NSura, totalTokens, vocabularySize);
        }

        function performItemSuraStatsSearch(statsInput, combinedData, statsMatchMode) {
            if (!statsInput || !statsInput.sections) return [];

            const checkedCount = statsInput.sections.length;
            const useCombinedAll = (statsMatchMode === 'all' && !highlightedItem && checkedCount > 1 && combinedData?.eligible);

            if (useCombinedAll) {
                const bySura = combinedData.bySura || {};
                const totalCS = Object.values(bySura).reduce((a, b) => a + b, 0);
                const suras = Object.keys(bySura).map(Number).sort((a, b) => a - b);
                let nTotalAyah = 0;
                for (const sk of Object.keys(morphologyData)) nTotalAyah += Object.keys(morphologyData[sk] || {}).length;
                if (nTotalAyah <= 0) nTotalAyah = 1;
                const rows = suras.map(sura => {
                    const cSura = bySura[sura] || 0;
                    const nSura = Math.max(1, Object.keys(morphologyData[sura] || {}).length);
                    const metrics = computePerSuraMetrics(cSura, totalCS, nSura, nTotalAyah, 1);
                    return {
                        sura,
                        count: cSura,
                        relInSura: metrics.relInSura,
                        ratio: metrics.ratio,
                        kl: metrics.kl,
                        m: metrics.m,
                        detail: { cSura, cAll: totalCS, nSura, nTotal: nTotalAyah, v: 1, alpha: STATS_ALPHA, pSura: metrics.pSura, pElse: metrics.pElse }
                    };
                });
                return [{ item: { type: 'text', display: 'ÿ™ÿ±⁄©€åÿ®€å (ŸáŸÖŸá ŸÖŸàÿßÿ±ÿØ)' }, itemIndex: 0, totalMatches: totalCS, rows, focusedLem: null }];
            }

            const sections = [];
            for (let i = 0; i < statsInput.sections.length; i++) {
                const { item, itemIndex, matches, focusedLem } = statsInput.sections[i];
                if (!item) continue;

                if (!matches || !matches.length) {
                    sections.push({ item, itemIndex, totalMatches: 0, rows: [], focusedLem });
                    continue;
                }

                const effectiveType = focusedLem ? 'lemma' : item.type;
                const universe = resolveStatsUniverse(effectiveType);
                const countsBySura = {};
                let totalMatchCount;
                const isPhraseText = item.type === 'text' && matches.some(m => m.phraseOccurrence !== undefined);
                if (isPhraseText) {
                    const seenOccs = new Set();
                    for (const m of matches) {
                        const oc = m.phraseOccurrence;
                        if (oc === undefined) continue;
                        if (seenOccs.has(oc)) continue;
                        seenOccs.add(oc);
                        countsBySura[m.sura] = (countsBySura[m.sura] || 0) + 1;
                    }
                    totalMatchCount = seenOccs.size;
                } else {
                    totalMatchCount = matches.length;
                    for (const m of matches) {
                        countsBySura[m.sura] = (countsBySura[m.sura] || 0) + 1;
                    }
                }

                const suras = Object.keys(countsBySura).map(Number).sort((a, b) => a - b);
                const rows = suras.map(sura => {
                    const cSura = countsBySura[sura] || 0;
                    const N_s = universe.tokensBySura[sura] || 1;
                    const metrics = computePerSuraMetrics(cSura, totalMatchCount, N_s, universe.totalTokens, universe.vocabularySize);
                    return {
                        sura,
                        count: cSura,
                        relInSura: metrics.relInSura,
                        ratio: metrics.ratio,
                        kl: metrics.kl,
                        m: metrics.m,
                        detail: {
                            cSura,
                            cAll: totalMatchCount,
                            nSura: N_s,
                            nTotal: universe.totalTokens,
                            v: universe.vocabularySize,
                            alpha: STATS_ALPHA,
                            pSura: metrics.pSura,
                            pElse: metrics.pElse
                        }
                    };
                });
                sections.push({ item, itemIndex, totalMatches: totalMatchCount, rows, focusedLem });
            }
            return sections;
        }
        
        // Convert intervals to displayable groups
        // Each group gets an intervalId to track which groups came from the same match
        function convertIntervalsToGroups(intervals, crossSura) {
            const groups = [];
            let intervalId = 0;
            
            for (const interval of intervals) {
                // Group matches by sura
                const bySura = {};
                for (const match of interval.matches) {
                    if (!bySura[match.sura]) bySura[match.sura] = [];
                    bySura[match.sura].push(match);
                }
                
                // Check if this interval spans multiple suras
                const suraCount = Object.keys(bySura).length;
                const currentIntervalId = intervalId++;
                
                // Create a group for each sura
                const suras = Object.keys(bySura).map(Number).sort((a, b) => a - b);
                for (let i = 0; i < suras.length; i++) {
                    const sura = suras[i];
                    const matches = bySura[sura];
                    const ayahs = matches.map(m => m.ayah);
                    const startAyah = Math.min(...ayahs);
                    const endAyah = Math.max(...ayahs);
                    
                    // Check if we can merge with existing group from same interval
                    let merged = false;
                    for (const group of groups) {
                        if (group.sura === sura && group.intervalId === currentIntervalId &&
                            ((startAyah >= group.startAyah - 1 && startAyah <= group.endAyah + 1) ||
                             (endAyah >= group.startAyah - 1 && endAyah <= group.endAyah + 1))) {
                            group.startAyah = Math.min(group.startAyah, startAyah);
                            group.endAyah = Math.max(group.endAyah, endAyah);
                            for (const m of matches) {
                                const exists = group.matches.some(
                                    gm => gm.sura === m.sura && gm.ayah === m.ayah && gm.wordIndex === m.wordIndex
                                );
                                if (!exists) {
                                    group.matches.push(m);
                                }
                            }
                            merged = true;
                            break;
                        }
                    }
                    
                    if (!merged) {
                        groups.push({ 
                            sura, 
                            startAyah, 
                            endAyah, 
                            matches: [...matches],
                            intervalId: currentIntervalId,
                            groupKey: `int-${currentIntervalId}-${sura}`,
                            isMultiSura: suraCount > 1,
                            isFirstInInterval: i === 0,
                            isLastInInterval: i === suras.length - 1
                        });
                    }
                }
            }
            
            return groups.sort((a, b) => {
                if (a.intervalId !== b.intervalId) return a.intervalId - b.intervalId;
                if (a.sura !== b.sura) return a.sura - b.sura;
                return a.startAyah - b.startAyah;
            });
        }

        // Recompute multi-sura first/last flags after edits (remove)
        function recomputeIntervalFlags(groups) {
            const byInterval = {};
            for (const g of groups) {
                // IMPORTANT: if intervalId is missing (e.g., focus-mode groups),
                // we must NOT group them together, otherwise regions "merge".
                const key = (g.intervalId === undefined || g.intervalId === null)
                    ? `single:${g.groupKey || `${g.sura}-${g.startAyah}-${g.endAyah}`}`
                    : `interval:${g.intervalId}`;
                if (!byInterval[key]) byInterval[key] = [];
                byInterval[key].push(g);
            }
            
            for (const key of Object.keys(byInterval)) {
                const list = byInterval[key].sort((a, b) => (a.sura - b.sura) || (a.startAyah - b.startAyah));
                const multi = list.length > 1;
                list.forEach((g, idx) => {
                    g.isMultiSura = multi;
                    g.isFirstInInterval = idx === 0;
                    g.isLastInInterval = idx === list.length - 1;
                });
            }
            
            return groups.sort((a, b) => {
                const aHas = !(a.intervalId === undefined || a.intervalId === null);
                const bHas = !(b.intervalId === undefined || b.intervalId === null);
                if (aHas && bHas && a.intervalId !== b.intervalId) return a.intervalId - b.intervalId;
                if (a.sura !== b.sura) return a.sura - b.sura;
                return a.startAyah - b.startAyah;
            });
        }

        // Region controls state
        let lastRenderedGroups = [];

        function clampGroupRange(group) {
            const maxAyah = (typeof SURA_AYAT !== 'undefined' && SURA_AYAT[group.sura]) ? SURA_AYAT[group.sura] : 9999;
            group.startAyah = Math.max(1, group.startAyah);
            group.endAyah = Math.min(maxAyah, group.endAyah);
            if (group.endAyah < group.startAyah) group.endAyah = group.startAyah;
        }

        function applyRegionAction(groupKey, action) {
            const group = lastRenderedGroups.find(g => g.groupKey === groupKey);
            if (!group) return;

            // Ensure base range exists (original search-produced bounds)
            if (group.baseStartAyah === undefined) group.baseStartAyah = group.startAyah;
            if (group.baseEndAyah === undefined) group.baseEndAyah = group.endAyah;
            
            if (action === 'remove') {
                lastRenderedGroups = lastRenderedGroups.filter(g => g.groupKey !== groupKey);
                lastRenderedGroups = recomputeIntervalFlags(lastRenderedGroups);
                renderResults(lastRenderedGroups);
                return;
            }

            if (action === 'reset') {
                group.startAyah = group.baseStartAyah;
                group.endAyah = group.baseEndAyah;
                clampGroupRange(group);
                renderResults(lastRenderedGroups);
                return;
            }
            
            const step = action.endsWith('5') ? 5 : 1;
            if (action.startsWith('before')) {
                group.startAyah -= step;
            } else if (action.startsWith('after')) {
                group.endAyah += step;
            }
            clampGroupRange(group);
            renderResults(lastRenderedGroups);
        }

        function getActiveHighlightSpecs() {
            // Returns array of { item, itemIndex, focusedLem, ignoreFilters }
            if (selectedItems.length === 0) return [];
            
            // Focus mode
            if (highlightedItem) {
                const itemIndex = highlightedItem.itemIndex;
                const item = selectedItems[itemIndex];
                if (!item) return [];
                
                if (highlightedItem.type === 'lem') {
                    return [{ item, itemIndex, focusedLem: highlightedItem.lem, ignoreFilters: false }];
                }
                // highlightedItem.type === 'item'
                return [{ item, itemIndex, focusedLem: null, ignoreFilters: true }];
            }
            
            // Normal mode: only checked items, respect LEM filtering for roots
            const specs = [];
            for (let itemIndex = 0; itemIndex < selectedItems.length; itemIndex++) {
                if (itemCheckedState[itemIndex] === false) continue;
                specs.push({ item: selectedItems[itemIndex], itemIndex, focusedLem: null, ignoreFilters: false });
            }
            return specs;
        }

        function computeHighlightMatchesForGroup(group) {
            const specs = getActiveHighlightSpecs();
            if (specs.length === 0) return [];
            
            const matches = [];
            for (const spec of specs) {
                const m = findMatchingWords(spec.item, spec.itemIndex, spec.focusedLem, spec.ignoreFilters) || [];
                for (const x of m) {
                    if (x.sura !== group.sura) continue;
                    if (x.ayah < group.startAyah || x.ayah > group.endAyah) continue;
                    // Ensure itemIndex present (needed for highlight color)
                    x.itemIndex = spec.itemIndex;
                    matches.push(x);
                }
            }
            return matches;
        }
        
        // Build a summary of the current search for tooltip
        function buildSearchSummary() {
            const lines = [];
            const typeLabels = { root: 'ÿ±€åÿ¥Ÿá', word: 'Ÿàÿß⁄òŸá', text: 'ÿπÿ®ÿßÿ±ÿ™' };
            
            // Search items
            lines.push('ÿ¨ÿ≥ÿ™ÿ¨Ÿà:');
            selectedItems.forEach((item, idx) => {
                const isChecked = itemCheckedState[idx] !== false;
                const checkMark = isChecked ? '‚úì' : '‚úó';
                let itemLine = `  ${checkMark} ${typeLabels[item.type]}: ${item.value}`;
                
                // For roots, show selected LEMs
                if (item.type === 'root' && rootLemData[item.value]) {
                    const lemData = rootLemData[item.value];
                    const selectedLems = lemData.lems.filter(l => l.selected);
                    const totalLems = lemData.lems.length;
                    
                    if (selectedLems.length < totalLems) {
                        const lemNames = selectedLems.map(l => l.lem).join('ÿå ');
                        itemLine += ` [${fmtFa(selectedLems.length)}/${fmtFa(totalLems)}: ${lemNames}]`;
                    } else {
                        itemLine += ` [ŸáŸÖŸá ${fmtFa(totalLems)} ÿµ€åÿ∫Ÿá]`;
                    }
                }
                
                lines.push(itemLine);
            });
            
            // Highlighted item (focus mode)
            if (highlightedItem) {
                const item = selectedItems[highlightedItem.itemIndex];
                if (highlightedItem.type === 'lem') {
                    lines.push(`\nÿ≠ÿßŸÑÿ™ ÿ™ŸÖÿ±⁄©ÿ≤: ÿµ€åÿ∫Ÿá "${highlightedItem.lem}" ÿßÿ≤ ÿ±€åÿ¥Ÿá "${item.value}"`);
                } else {
                    lines.push(`\nÿ≠ÿßŸÑÿ™ ÿ™ŸÖÿ±⁄©ÿ≤: ${typeLabels[item.type]} "${item.value}"`);
                }
            }
            
            // Distance
            const distance = getDistanceValueClamped();
            lines.push(`\nŸÅÿßÿµŸÑŸá: ${fmtFa(distance)} ÿ¢€åŸá`);
            
            // Cross-sura
            const crossSura = document.getElementById('cross-sura-toggle')?.getAttribute('aria-pressed') === 'true';
            lines.push(`ÿπÿ®Ÿàÿ± ÿßÿ≤ ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß: ${crossSura ? 'ÿ®ŸÑŸá' : 'ÿÆ€åÿ±'}`);
            
            // Sura filter
            if (allSurasSelected) {
                lines.push(`ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß: ŸáŸÖŸá`);
            } else if (selectedSuras.size === 0) {
                lines.push(`ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß: Ÿá€å⁄Ü‚Äå⁄©ÿØÿßŸÖ`);
            } else {
                const suraNames = [...selectedSuras]
                    .sort((a, b) => a - b)
                    .map(s => SURA_NAMES[s] || s)
                    .join('ÿå ');
                lines.push(`ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß (${fmtFa(selectedSuras.size)}): ${suraNames}`);
            }
            
            return lines.join('\n');
        }

        function buildCopyPayloadText() {
            const groups = Array.isArray(lastRenderedGroups) ? lastRenderedGroups : [];
            if (groups.length === 0) {
                const t = new Date().toLocaleString('fa-IR');
                return `ŸÜÿ™€åÿ¨Ÿá‚Äåÿß€å ÿ®ÿ±ÿß€å ⁄©Ÿæ€å Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.\n\nÿ≤ŸÖÿßŸÜ: ${t}\n\n${buildSearchSummary()}`;
            }
            
            // One paragraph per region (group)
            const paragraphs = [];
            for (const group of groups) {
                const parts = [];
                for (let ayah = group.startAyah; ayah <= group.endAyah; ayah++) {
                    const ayahText = getAyahText(group.sura, ayah);
                    if (!ayahText) continue;
                    // Put reference at end (consistent with UI paragraph mode)
                    parts.push(`${ayahText} (${SURA_NAMES[group.sura]} ${fmtFa(ayah)})`);
                }
                if (parts.length) paragraphs.push(parts.join(' '));
            }
            
            const t = new Date().toLocaleString('fa-IR');
            const desc = buildSearchSummary();
            return `${paragraphs.join('\n\n')}\n\n‚Äî\nÿ≤ŸÖÿßŸÜ ÿ¨ÿ≥ÿ™ÿ¨Ÿà: ${t}\n\n${desc}`;
        }

        const HIGHLIGHT_BG_COLORS = ['#a5d6a7','#90caf9','#ffcc80','#ce93d8','#fff59d','#f48fb1','#80deea','#bcaaa4'];
        const HIGHLIGHT_TEXT_COLORS = ['#2e7d32','#1565c0','#ef6c00','#6a1b9a','#8d6e00','#ad1457','#00838f','#5d4037'];

        function escapeHtml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        function buildHighlightedAyahHTML(sura, ayah, highlightMatchesForGroup) {
            const ayahData = morphologyData[sura]?.[ayah];
            if (!ayahData) return escapeHtml(getAyahText(sura, ayah));
            
            const mode = localStorage.getItem('searchHighlightMode') || 'background';
            const wordIndices = Object.keys(ayahData).map(Number).sort((a, b) => a - b);
            const matchMap = new Map(); // wordIndex -> itemIndex
            for (const m of (highlightMatchesForGroup || [])) {
                if (m.sura === sura && m.ayah === ayah) {
                    matchMap.set(m.wordIndex, m.itemIndex ?? 0);
                }
            }
            
            const parts = [];
            for (const idx of wordIndices) {
                const word = ayahData[idx]?.text || '';
                const itemIndex = matchMap.get(idx);
                if (itemIndex !== undefined) {
                    const c = (itemIndex % 8 + 8) % 8;
                    const style = (mode === 'text')
                        ? `color:${HIGHLIGHT_TEXT_COLORS[c]};font-weight:700;display:inline-block;`
                        // No padding here: LibreOffice tends to highlight NBSP separators as visible dark blocks
                        : `background-color:${HIGHLIGHT_BG_COLORS[c]};border-radius:2px;display:inline-block;`;
                    parts.push(`<span style="${style}">${escapeHtml(word)}</span>`);
                } else {
                    parts.push(escapeHtml(word));
                }
            }
            // Use explicit spacer element so LibreOffice doesn't merge the separator space into a highlighted span
            const spacer = `<span style="background-color:transparent;color:inherit;display:inline;"> </span>`;
            return parts.join(spacer);
        }

        function buildCopyPayloadHTML() {
            const groups = Array.isArray(lastRenderedGroups) ? lastRenderedGroups : [];
            const t = new Date().toLocaleString('fa-IR');
            const desc = escapeHtml(buildSearchSummary());
            
            if (groups.length === 0) {
                return `<div dir="rtl" lang="fa" style="direction:rtl;unicode-bidi:plaintext;text-align:right;font-family:inherit;">
                    <p style="margin:0 0 10px 0;">ŸÜÿ™€åÿ¨Ÿá‚Äåÿß€å ÿ®ÿ±ÿß€å ⁄©Ÿæ€å Ÿàÿ¨ŸàÿØ ŸÜÿØÿßÿ±ÿØ.</p>
                    <div style="white-space:pre-wrap;color:#444;font-size:12px;">ÿ≤ŸÖÿßŸÜ: ${escapeHtml(t)}\n\n${desc}</div>
                </div>`;
            }
            
            const paras = [];
            for (const group of groups) {
                const highlightMatchesForGroup = computeHighlightMatchesForGroup(group);
                const ayahParts = [];
                for (let ay = group.startAyah; ay <= group.endAyah; ay++) {
                    const ayahHtml = buildHighlightedAyahHTML(group.sura, ay, highlightMatchesForGroup);
                    const ref = `${SURA_NAMES[group.sura]} ${fmtFa(ay)}`;
                    ayahParts.push(`${ayahHtml} <span style="color:#777;font-size:11px;">(${escapeHtml(ref)})</span>`);
                }
                paras.push(`<p dir="rtl" style="margin:0 0 12px 0;line-height:2;direction:rtl;unicode-bidi:plaintext;text-align:right;">${ayahParts.join(' ')}</p>`);
            }
            
            return `<div dir="rtl" lang="fa" style="direction:rtl;unicode-bidi:plaintext;text-align:right;font-family:inherit;">
                ${paras.join('')}
                <div style="margin:8px 0;border-top:1px solid #ddd;"></div>
                <div style="white-space:pre-wrap;color:#444;font-size:12px;">ÿ≤ŸÖÿßŸÜ ÿ¨ÿ≥ÿ™ÿ¨Ÿà: ${escapeHtml(t)}\n\n${desc}</div>
            </div>`;
        }

        function copyWithCopyEvent({ html, text }) {
            // Robust fallback: force-set clipboard types during the copy event.
            // This is often more reliable than relying on the browser to infer HTML from selection.
            const container = document.createElement('div');
            container.contentEditable = 'true';
            container.style.position = 'fixed';
            container.style.left = '-9999px';
            container.style.top = '0';
            container.style.width = '1px';
            container.style.height = '1px';
            container.style.overflow = 'hidden';
            container.style.opacity = '1';
            container.innerHTML = html;
            document.body.appendChild(container);
            
            const range = document.createRange();
            range.selectNodeContents(container);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
            
            const handler = (e) => {
                try {
                    e.clipboardData.setData('text/html', html);
                    e.clipboardData.setData('text/plain', text);
                    e.preventDefault();
                } catch (_) {
                    // ignore
                }
            };
            
            document.addEventListener('copy', handler, { once: true });
            const ok = document.execCommand('copy');
            
            sel.removeAllRanges();
            container.remove();
            return ok;
        }

        async function copyToClipboard({ text, html }) {
            // Prefer rich clipboard (keeps highlights in Word/Google Docs)
            try {
                if (navigator.clipboard?.write && typeof ClipboardItem !== 'undefined') {
                    const item = new ClipboardItem({
                        'text/plain': new Blob([text], { type: 'text/plain' }),
                        'text/html': new Blob([html], { type: 'text/html' })
                    });
                    await navigator.clipboard.write([item]);
                    console.log('[copy] rich clipboard (ClipboardItem) used');
                    return;
                }
            } catch (e) {
                console.warn('[copy] rich clipboard failed, falling back', e);
            }
            
            // Fallback to plain text
            try {
                // Prefer copy-event forced HTML fallback before plain text (better for Word/Docs)
                const ok = copyWithCopyEvent({ html, text });
                if (ok) {
                    console.log('[copy] execCommand copy-event html used');
                    return;
                }
            } catch (e) {
                console.warn('[copy] execCommand copy-event failed, falling back to text', e);
            }
            
            if (navigator.clipboard?.writeText) {
                await navigator.clipboard.writeText(text);
                console.log('[copy] plain text clipboard used');
                return;
            }
            
            const ta = document.createElement('textarea');
            ta.value = text;
            ta.setAttribute('readonly', '');
            ta.style.position = 'fixed';
            ta.style.opacity = '0';
            ta.style.left = '-9999px';
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            ta.remove();
        }
        
        // Group matches by region for single item search
        // Always creates separate groups for each sura
        function groupMatchesByRegion(matches, crossSura) {
            const groups = [];
            const sorted = [...matches].sort(comparePositions);
            
            let currentGroup = null;
            
            for (const match of sorted) {
                if (!currentGroup) {
                    currentGroup = { sura: match.sura, startAyah: match.ayah, endAyah: match.ayah, matches: [match] };
                } else if (match.sura === currentGroup.sura && match.ayah <= currentGroup.endAyah + 1) {
                    // Same sura and adjacent ayah - merge
                    currentGroup.matches.push(match);
                    currentGroup.endAyah = Math.max(currentGroup.endAyah, match.ayah);
                } else {
                    // Different sura or non-adjacent - create new group
                    groups.push(currentGroup);
                    currentGroup = { sura: match.sura, startAyah: match.ayah, endAyah: match.ayah, matches: [match] };
                }
            }
            
            if (currentGroup) {
                groups.push(currentGroup);
            }
            
            return groups;
        }
        
        // Get ayah text
        function getAyahText(sura, ayah) {
            const ayahData = morphologyData[sura]?.[ayah];
            if (!ayahData) return '';
            
            const words = [];
            const wordIndices = Object.keys(ayahData).map(Number).sort((a, b) => a - b);
            for (const idx of wordIndices) {
                if (ayahData[idx]?.text) {
                    words.push(ayahData[idx].text);
                }
            }
            return words.join(' ');
        }

        function fmtFaPercent(value) {
            if (!Number.isFinite(value)) return '€∞Ÿ™';
            return fmtFa((value * 100).toFixed(2)) + 'Ÿ™';
        }

        function fmtFaFloat(value, fractionDigits) {
            if (!Number.isFinite(value)) return '€∞';
            return new Intl.NumberFormat('fa-IR', {
                maximumFractionDigits: fractionDigits,
                minimumFractionDigits: 0
            }).format(value);
        }

        function measureHeaderTooltip(kind) {
            if (kind === 'freq') return { title: 'ŸÅÿ±ÿßŸàÿßŸÜ€å ÿØÿ± ÿ≥Ÿàÿ±Ÿá', formulaHtml: 'rel = <span class="frac"><span class="num">c<sub>s</sub></span><span class="den">N<sub>s</sub></span></span>', text: 'ŸÜÿ≥ÿ®ÿ™ ŸàŸÇŸàÿπ ŸÖŸàÿ±ÿØ ÿØÿ± ŸáŸÖÿßŸÜ ÿ≥Ÿàÿ±Ÿá.' };
            if (kind === 'ratio') return { title: 'ÿ™ŸÖÿß€åÿ≤ (Ratio)', formulaHtml: 'ratio = <span class="frac"><span class="num"><span class="frac"><span class="num">c<sub>s</sub> + a</span><span class="den">N<sub>s</sub> + aV</span></span></span><span class="den"><span class="frac"><span class="num">c<sub>e</sub> + a</span><span class="den">N<sub>e</sub> + aV</span></span></span></span>', text: 'Ÿáÿ±⁄ÜŸá ÿ®ÿ≤ÿ±⁄Ø‚Äåÿ™ÿ± ÿ®ÿßÿ¥ÿØÿå ŸÖŸàÿ±ÿØ ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿ≥ÿß€åÿ± ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß ŸÖÿ™ŸÖÿß€åÿ≤ÿ™ÿ± ÿßÿ≥ÿ™.' };
            if (kind === 'kl') return { title: 'KL Contribution', formulaHtml: 'KL = p<sub>s</sub> ln(<span class="frac"><span class="num">p<sub>s</sub></span><span class="den">p<sub>e</sub></span></span>)', text: 'ÿ≥ŸáŸÖ ŸÖŸàÿ±ÿØ ÿØÿ± Ÿàÿß⁄Øÿ±ÿß€å€å ÿ™Ÿàÿ≤€åÿπ ÿØÿßÿÆŸÑ ÿ≥Ÿàÿ±Ÿá ŸÜÿ≥ÿ®ÿ™ ÿ®Ÿá ÿ®€åÿ±ŸàŸÜ ÿ≥Ÿàÿ±Ÿá.' };
            return { title: 'N¬≤/N', formulaHtml: 'm = <span class="frac"><span class="num">c<sub>s</sub> ¬∑ p<sub>s</sub></span><span class="den">q</span></span>', text: 'q ÿßÿ≠ÿ™ŸÖÿßŸÑ ⁄©ŸÑ€å ŸÖŸàÿ±ÿØ ÿØÿ± ⁄©ŸÑ ÿØÿßŸÖŸÜŸá ÿßÿ≥ÿ™.' };
        }

        function measureCellTooltip(kind, row) {
            const d = row.detail || {};
            const head = measureHeaderTooltip(kind);
            const cs = d.cSura || 0;
            const ca = d.cAll || 0;
            const ns = d.nSura || 1;
            const nt = d.nTotal || 1;
            const v = d.v || 1;
            const a = d.alpha || STATS_ALPHA;
            const ce = Math.max(0, ca - cs);
            const ne = Math.max(1, nt - ns);
            const ps = Number.isFinite(d.pSura) ? d.pSura : ((cs + a) / (ns + a * v));
            const pe = Number.isFinite(d.pElse) ? d.pElse : ((ce + a) / (ne + a * v));
            const q = (ca + a) / (nt + a * v);

            let vars = [];
            if (kind === 'freq') vars = [
                { name: 'rel', meaning: 'ŸÅÿ±ÿßŸàÿßŸÜ€å ÿØÿ± ÿ≥Ÿàÿ±Ÿá', value: fmtFaPercent(row.relInSura) },
                { name: 'c<sub>s</sub>', meaning: 'ÿ™ÿπÿØÿßÿØ ŸàŸÇŸàÿπ ŸÖŸàÿ±ÿØ ÿØÿ± ŸáŸÖ€åŸÜ ÿ≥Ÿàÿ±Ÿá', value: fmtFa(cs) },
                { name: 'N<sub>s</sub>', meaning: '⁄©ŸÑ ÿ™Ÿà⁄©ŸÜ‚ÄåŸáÿß€å ŸáŸÖÿßŸÜ ŸÜŸàÿπ ÿØÿ± ŸáŸÖ€åŸÜ ÿ≥Ÿàÿ±Ÿá', value: fmtFa(ns) }
            ];
            else if (kind === 'ratio') vars = [
                { name: 'ratio', meaning: 'ÿ¥ÿßÿÆÿµ ÿ™ŸÖÿß€åÿ≤', value: fmtFaFloat(row.ratio, 3) },
                { name: 'c<sub>s</sub>', meaning: 'ÿ™ÿπÿØÿßÿØ ŸàŸÇŸàÿπ ŸÖŸàÿ±ÿØ ÿØÿ± ŸáŸÖ€åŸÜ ÿ≥Ÿàÿ±Ÿá', value: fmtFa(cs) },
                { name: 'a', meaning: 'ÿ∂ÿ±€åÿ® ŸáŸÖŸàÿßÿ±ÿ≥ÿßÿ≤€å', value: fmtFa(a) },
                { name: 'N<sub>s</sub>', meaning: '⁄©ŸÑ ÿ™Ÿà⁄©ŸÜ‚ÄåŸáÿß€å ŸáŸÖÿßŸÜ ŸÜŸàÿπ ÿØÿ± ŸáŸÖ€åŸÜ ÿ≥Ÿàÿ±Ÿá', value: fmtFa(ns) },
                { name: 'V', meaning: 'ÿ™ÿπÿØÿßÿØ ÿßŸÜŸàÿßÿπ €å⁄©ÿ™ÿß€å ŸáŸÖÿßŸÜ ŸÜŸàÿπ', value: fmtFa(v) },
                { name: 'c<sub>e</sub>', meaning: 'ÿ™ÿπÿØÿßÿØ ŸàŸÇŸàÿπ ŸÖŸàÿ±ÿØ ÿØÿ± ÿ≥ÿß€åÿ± ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß', value: fmtFa(ce) },
                { name: 'N<sub>e</sub>', meaning: '⁄©ŸÑ ÿ™Ÿà⁄©ŸÜ‚ÄåŸáÿß€å ŸáŸÖÿßŸÜ ŸÜŸàÿπ ÿØÿ± ÿ≥ÿß€åÿ± ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß', value: fmtFa(ne) }
            ];
            else if (kind === 'kl') vars = [
                { name: 'KL', meaning: 'ÿ≥ŸáŸÖ Ÿàÿß⁄Øÿ±ÿß€å€å KL', value: fmtFaFloat(row.kl, 4) },
                { name: 'p<sub>s</sub>', meaning: 'ÿßÿ≠ÿ™ŸÖÿßŸÑ ŸáŸÖŸàÿßÿ±ÿ¥ÿØŸá ÿØÿßÿÆŸÑ ÿ≥Ÿàÿ±Ÿá', value: fmtFaFloat(ps, 8) },
                { name: 'p<sub>e</sub>', meaning: 'ÿßÿ≠ÿ™ŸÖÿßŸÑ ŸáŸÖŸàÿßÿ±ÿ¥ÿØŸá ÿÆÿßÿ±ÿ¨ ÿ≥Ÿàÿ±Ÿá', value: fmtFaFloat(pe, 8) }
            ];
            else vars = [
                { name: 'm', meaning: 'ÿ¥ÿßÿÆÿµ N¬≤/N', value: fmtFaFloat(row.m, 3) },
                { name: 'c<sub>s</sub>', meaning: 'ÿ™ÿπÿØÿßÿØ ŸàŸÇŸàÿπ ŸÖŸàÿ±ÿØ ÿØÿ± ŸáŸÖ€åŸÜ ÿ≥Ÿàÿ±Ÿá', value: fmtFa(cs) },
                { name: 'p<sub>s</sub>', meaning: 'ÿßÿ≠ÿ™ŸÖÿßŸÑ ŸáŸÖŸàÿßÿ±ÿ¥ÿØŸá ÿØÿßÿÆŸÑ ÿ≥Ÿàÿ±Ÿá', value: fmtFaFloat(ps, 8) },
                { name: 'q', meaning: 'ÿßÿ≠ÿ™ŸÖÿßŸÑ ŸáŸÖŸàÿßÿ±ÿ¥ÿØŸá ⁄©ŸÑ€å ÿØÿ± ÿØÿßŸÖŸÜŸá', value: fmtFaFloat(q, 8) }
            ];

            const varsHtml = vars.map(vr => '<div class="var-line"><strong>' + vr.name + '</strong>: ' + escapeHtml(vr.meaning) + ' = ' + escapeHtml(vr.value) + '</div>').join('');
            return '<div class="title">' + escapeHtml(head.title) + '</div>' +
                   '<div class="formula-render">' + head.formulaHtml + '</div>' +
                   '<div>' + escapeHtml(head.text) + '</div>' + varsHtml;
        }

        let measureTooltipEl = null;
        function ensureMeasureTooltip() {
            if (measureTooltipEl) return measureTooltipEl;
            measureTooltipEl = document.createElement('div');
            measureTooltipEl.id = 'measure-tooltip';
            document.body.appendChild(measureTooltipEl);
            return measureTooltipEl;
        }
        function positionMeasureTooltipForCell(cell) {
            const el = ensureMeasureTooltip();
            const cellRect = cell.getBoundingClientRect();
            const tooltipRect = el.getBoundingClientRect();
            const vw = window.innerWidth || document.documentElement.clientWidth;
            const vh = window.innerHeight || document.documentElement.clientHeight;
            const gap = 6;
            let left = cellRect.left + (cellRect.width - tooltipRect.width) / 2;
            let top;
            if (cellRect.top >= tooltipRect.height + gap) {
                top = cellRect.top - tooltipRect.height - gap;
            } else {
                top = cellRect.bottom + gap;
            }
            if (left < 8) left = 8;
            if (left + tooltipRect.width > vw - 8) left = vw - tooltipRect.width - 8;
            if (top < 8) top = 8;
            if (top + tooltipRect.height > vh - 8) top = vh - tooltipRect.height - 8;
            el.style.left = left + 'px';
            el.style.top = top + 'px';
        }
        function showMeasureTooltip(html, cell) {
            const el = ensureMeasureTooltip();
            el.innerHTML = html;
            el.classList.add('visible');
            requestAnimationFrame(() => positionMeasureTooltipForCell(cell));
        }
        function hideMeasureTooltip() {
            if (!measureTooltipEl) return;
            measureTooltipEl.classList.remove('visible');
        }

        function sortStatsRows(rows) {
            const key = statsSortKey || 'sura';
            const dir = statsSortDir === 'desc' ? -1 : 1;
            const sorted = Array.isArray(rows) ? [...rows] : [];
            sorted.sort((a, b) => {
                const va = Number(a && a[key]);
                const vb = Number(b && b[key]);
                if (!Number.isFinite(va) && !Number.isFinite(vb)) return 0;
                if (!Number.isFinite(va)) return 1;
                if (!Number.isFinite(vb)) return -1;
                if (va === vb) return Number(a.sura) - Number(b.sura);
                return (va - vb) * dir;
            });
            return sorted;
        }

        function sortIndicatorFor(key) {
            if (statsSortKey !== key) return '';
            return statsSortDir === 'desc' ? ' ‚ñº' : ' ‚ñ≤';
        }

        function statsSortLabel(key) {
            const map = {
                sura: 'ÿ≥Ÿàÿ±Ÿá',
                count: 'ÿ™ÿπÿØÿßÿØ',
                relInSura: 'ŸÅÿ±ÿßŸàÿßŸÜ€å',
                ratio: 'ÿ™ŸÖÿß€åÿ≤',
                kl: 'KL',
                m: 'N¬≤/N'
            };
            return map[key] || 'ÿ≥Ÿàÿ±Ÿá';
        }

        function statsSortControlsHtml() {
            const options = [
                ['sura', 'ÿ≥Ÿàÿ±Ÿá'],
                ['count', 'ÿ™ÿπÿØÿßÿØ'],
                ['relInSura', 'ŸÅÿ±ÿßŸàÿßŸÜ€å'],
                ['ratio', 'ÿ™ŸÖÿß€åÿ≤'],
                ['kl', 'KL'],
                ['m', 'N¬≤/N']
            ];
            const opts = options.map(([k, t]) => `<option value="${k}" ${statsSortKey === k ? 'selected' : ''}>${t}</option>`).join('');
            return `<span class="stats-sort-controls">` +
                `<select id="stats-sort-select" class="stats-sort-select" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å">${opts}</select>` +
                `<button type="button" id="stats-sort-dir" class="stats-sort-dir-btn" title="ÿ™ÿ∫€å€åÿ± ÿ¨Ÿáÿ™ ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å">${statsSortDir === 'desc' ? 'ŸÜÿ≤ŸàŸÑ€å' : 'ÿµÿπŸàÿØ€å'}</button>` +
                `</span>`;
        }

        function renderStatsCharts(itemSections, resultsContent) {
            if (!itemSections || itemSections.length === 0) {
                resultsContent.innerHTML = '<div class="no-results">ŸÜÿ™€åÿ¨Ÿá‚Äåÿß€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ</div>';
                lastRenderedStats = [];
                return;
            }
            lastRenderedStats = itemSections;
            const foundSuraCount = itemSections.reduce((sum, sec) => sum + ((sec.rows && sec.rows.length) || 0), 0);
            let html = '';
            html += `<div class="stats-panel-toolbar">`;
            html += `<span class="stats-found-suras num-hindi">${fmtFa(foundSuraCount)} ÿ≥Ÿàÿ±Ÿá</span>`;
            html += `<button type="button" class="stats-match-toggle" id="stats-match-toggle" aria-pressed="${statsMatchMode === 'all' ? 'true' : 'false'}" title="ŸáŸÖŸá: ÿ™ÿπÿØÿßÿØ ÿ¢€åÿßÿ™ ÿ¥ÿ±Ÿàÿπ ⁄©Ÿá ŸáŸÖŸá ŸÖŸàÿßÿ±ÿØ ÿØÿ± ŸÅÿßÿµŸÑŸá ÿØÿßÿ±ŸÜÿØÿõ Ÿáÿ± ⁄©ÿØÿßŸÖ: ÿ¢ŸÖÿßÿ± ÿ¨ÿØÿß⁄ØÿßŸÜŸá Ÿáÿ± ŸÖŸàÿ±ÿØ"><span class="stats-match-dot" aria-hidden="true"></span>${statsMatchMode === 'all' ? 'ŸáŸÖŸá' : 'Ÿáÿ± ⁄©ÿØÿßŸÖ'}</button>`;
            html += statsSortControlsHtml();
            html += `</div>`;

            const typeLabels = { root: 'ÿ±€åÿ¥Ÿá', word: 'Ÿàÿß⁄òŸá', text: 'ÿπÿ®ÿßÿ±ÿ™', lemma: 'ŸÑŸÖŸá' };
            const series = [
                { key: 'count', label: 'ÿ™ÿπÿØÿßÿØ', color: '#dc2626' },
                { key: 'relInSura', label: 'ŸÅÿ±ÿßŸàÿßŸÜ€å', color: '#2563eb' },
                { key: 'ratio', label: 'ÿ™ŸÖÿß€åÿ≤', color: '#ea580c' },
                { key: 'kl', label: 'KL', color: '#7c3aed' },
                { key: 'm', label: 'N¬≤/N', color: '#0f766e' }
            ];

            for (let i = 0; i < itemSections.length; i++) {
                const sec = itemSections[i];
                const item = sec.item || {};
                const itemLabel = escapeHtml(sec.focusedLem ? `${item.value} ‚Üê ${sec.focusedLem}` : (item.display || item.value || ''));
                const typeLabel = typeLabels[sec.focusedLem ? 'lemma' : item.type] || 'ŸÖŸàÿ±ÿØ';
                html += `<div class="item-stats-card"><div class="item-stats-header"><span class="item-stats-title">${itemLabel}</span><span class="item-stats-type">${typeLabel}</span><span class="item-stats-total num-hindi" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å: ${statsSortLabel(statsSortKey)}">${fmtFa(sec.totalMatches || 0)} ÿ™ÿ∑ÿßÿ®ŸÇ</span></div>`;
                if (!sec.rows || sec.rows.length === 0) {
                    html += `<div class="no-results">ÿØÿ± ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß€å ÿßŸÜÿ™ÿÆÿßÿ®‚Äåÿ¥ÿØŸá ŸÖŸàÿ±ÿØ€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ</div>`;
                    html += `</div>`;
                    continue;
                }
                html += `<div class="item-stats-chart-wrap"><div id="item-stats-chart-${i}" class="item-stats-chart"></div></div>`;
                html += `</div>`;
            }
            resultsContent.innerHTML = html;

            if (typeof Plotly === 'undefined') {
                resultsContent.querySelectorAll('.item-stats-chart').forEach(el => {
                    el.innerHTML = '<div class="no-results">Plotly ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ŸÜÿ¥ÿØ.</div>';
                });
                return;
            }
            for (let i = 0; i < itemSections.length; i++) {
                const sec = itemSections[i];
                if (!sec.rows || sec.rows.length === 0) continue;
                const target = document.getElementById(`item-stats-chart-${i}`);
                if (!target) continue;
                // In chart mode, honor active sort controls for x-order as well.
                const rows = sortStatsRows(sec.rows);
                const suraLabelByNum = {};
                const tickText = rows.map(r => {
                    const s = Number(r.sura);
                    const name = SURA_NAMES[s] || ('ÿ≥Ÿàÿ±Ÿá ' + fmtFa(s));
                    const label = `${name}\u00A0${fmtFa(s)}`;
                    suraLabelByNum[s] = label;
                    return label;
                });
                const x = [...tickText];
                const maxima = {};
                const minima = {};
                const axisRanges = {};
                let hasAnyNegative = false;
                series.forEach(s => {
                    let mmax = 0;
                    let mmin = Number.POSITIVE_INFINITY;
                    rows.forEach(r => {
                        const v = Number(r[s.key]) || 0;
                        if (v > mmax) mmax = v;
                        if (v < mmin) mmin = v;
                    });
                    if (!Number.isFinite(mmin)) mmin = 0;
                    maxima[s.key] = Number.isFinite(mmax) ? mmax : 0;
                    minima[s.key] = mmin;
                    if (mmin < 0) hasAnyNegative = true;
                });
                series.forEach(s => {
                    let lo = minima[s.key];
                    let hi = maxima[s.key];
                    if (hasAnyNegative) {
                        // Keep per-series scaling, but align 0 across all overlaid axes.
                        const bound = Math.max(Math.abs(lo), Math.abs(hi), 1e-6);
                        const pad = Math.max(1e-6, bound * 0.08);
                        lo = -(bound + pad);
                        hi = bound + pad;
                        axisRanges[s.key] = [lo, hi];
                        return;
                    }
                    if (hi === lo) {
                        const pad = Math.max(1e-6, Math.abs(lo || 1) * 0.1);
                        lo -= pad;
                        hi += pad;
                    } else {
                        // Keep axis anchored at 0 unless negatives exist.
                        // If negatives exist, include them and show zero line in between.
                        if (lo >= 0) lo = 0;
                        // Add breathing room so edge points are fully visible.
                        const span = hi - lo;
                        const pad = Math.max(1e-6, span * 0.08);
                        if (lo < 0) lo -= pad;
                        hi += pad;
                    }
                    axisRanges[s.key] = [lo, hi];
                });
                const axisIds = ['y', 'y2', 'y3', 'y4', 'y5'];
                const traces = series.map((s, si) => ({
                    x,
                    y: rows.map(r => Number(r[s.key]) || 0),
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: `${s.label} (max: ${fmtFaFloat(maxima[s.key], 4)})`,
                    yaxis: axisIds[si],
                    line: { color: s.color, width: 2 },
                    marker: { color: s.color, size: 5 },
                    customdata: rows.map(r => suraLabelByNum[Number(r.sura)] || `ÿ≥Ÿàÿ±Ÿá ${r.sura}`),
                    // hovertemplate: `${s.label}: %{y:.6f}, ÿ≥Ÿàÿ±Ÿá\u00A0%{customdata}<extra></extra>`
                    hovertemplate: `${s.label}: %{y:.6f}<extra></extra>`
                }));
                const layout = {
                    margin: { l: 42, r: 28, t: 56, b: 92 },
                    paper_bgcolor: '#fcfdff',
                    plot_bgcolor: '#fcfdff',
                    hovermode: 'x unified',
                    hoverlabel: { namelength: -1 },
                    showlegend: true,
                    legend: { orientation: 'h', y: 1.0, x: 0, xanchor: 'left', yanchor: 'bottom' },
                    xaxis: {
                        title: '',
                        domain: [0, 0.925],
                        type: 'category',
                        categoryorder: 'array',
                        categoryarray: x,
                        automargin: true,
                        tickangle: -90
                    },
                    yaxis:  { title: '', tickfont: { color: series[0].color, size: 10 }, range: axisRanges[series[0].key], showline: true, linecolor: series[0].color, linewidth: 1, zeroline: true, zerolinecolor: '#94a3b8', zerolinewidth: 1 },
                    yaxis2: { title: '', tickfont: { color: series[1].color, size: 5 }, range: axisRanges[series[1].key], overlaying: 'y', side: 'right', anchor: 'free', position: 0.92, showline: true, linecolor: series[1].color, linewidth: 1, zeroline: true, zerolinecolor: '#94a3b8', zerolinewidth: 1 },
                    yaxis3: { title: '', tickfont: { color: series[2].color, size: 5 }, range: axisRanges[series[2].key], overlaying: 'y', side: 'right', anchor: 'free', position: 0.90, showline: true, linecolor: series[2].color, linewidth: 1, zeroline: true, zerolinecolor: '#94a3b8', zerolinewidth: 1 },
                    yaxis4: { title: '', tickfont: { color: series[3].color, size: 5 }, range: axisRanges[series[3].key], overlaying: 'y', side: 'right', anchor: 'free', position: 0.96, showline: true, linecolor: series[3].color, linewidth: 1, zeroline: true, zerolinecolor: '#94a3b8', zerolinewidth: 1 },
                    yaxis5: { title: '', tickfont: { color: series[4].color, size: 5 }, range: axisRanges[series[4].key], overlaying: 'y', side: 'right', anchor: 'free', position: 1.00, showline: true, linecolor: series[4].color, linewidth: 1, zeroline: true, zerolinecolor: '#94a3b8', zerolinewidth: 1 }
                };
                Plotly.newPlot(target, traces, layout, { displayModeBar: false, responsive: true });
            }
        }

        function renderStatsResults(itemSections, resultsContent) {
            if (!itemSections || itemSections.length === 0) {
                resultsContent.innerHTML = '<div class="no-results">ŸÜÿ™€åÿ¨Ÿá‚Äåÿß€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ</div>';
                lastRenderedStats = [];
                return;
            }

            lastRenderedStats = itemSections;
            const foundSuraCount = itemSections.reduce((sum, sec) => sum + ((sec.rows && sec.rows.length) || 0), 0);
            let html = '';
            html += `<div class="stats-panel-toolbar">`;
            html += `<span class="stats-found-suras num-hindi">${fmtFa(foundSuraCount)} ÿ≥Ÿàÿ±Ÿá</span>`;
            html += `<button type="button" class="stats-match-toggle" id="stats-match-toggle" aria-pressed="${statsMatchMode === 'all' ? 'true' : 'false'}" title="ŸáŸÖŸá: ÿ™ÿπÿØÿßÿØ ÿ¢€åÿßÿ™ ÿ¥ÿ±Ÿàÿπ ⁄©Ÿá ŸáŸÖŸá ŸÖŸàÿßÿ±ÿØ ÿØÿ± ŸÅÿßÿµŸÑŸá ÿØÿßÿ±ŸÜÿØÿõ Ÿáÿ± ⁄©ÿØÿßŸÖ: ÿ¢ŸÖÿßÿ± ÿ¨ÿØÿß⁄ØÿßŸÜŸá Ÿáÿ± ŸÖŸàÿ±ÿØ"><span class="stats-match-dot" aria-hidden="true"></span>${statsMatchMode === 'all' ? 'ŸáŸÖŸá' : 'Ÿáÿ± ⁄©ÿØÿßŸÖ'}</button>`;
            html += statsSortControlsHtml();
            html += `</div>`;
            const typeLabels = { root: 'ÿ±€åÿ¥Ÿá', word: 'Ÿàÿß⁄òŸá', text: 'ÿπÿ®ÿßÿ±ÿ™', lemma: 'ŸÑŸÖŸá' };
            for (let i = 0; i < itemSections.length; i++) {
                const sec = itemSections[i];
                const item = sec.item || {};
                const colorIndex = (sec.itemIndex ?? i) % 8;
                const itemLabel = escapeHtml(sec.focusedLem ? `${item.value} ‚Üê ${sec.focusedLem}` : (item.display || item.value || ''));
                const typeLabel = typeLabels[sec.focusedLem ? 'lemma' : item.type] || 'ŸÖŸàÿ±ÿØ';
                const matchesTitle = statsMatchMode === 'all' && sec.item?.display === 'ÿ™ÿ±⁄©€åÿ®€å (ŸáŸÖŸá ŸÖŸàÿßÿ±ÿØ)'
                    ? 'ÿ™ÿπÿØÿßÿØ ÿ¢€åÿßÿ™ ÿ¥ÿ±Ÿàÿπ ⁄©Ÿá ŸáŸÖŸá ŸÖŸàÿßÿ±ÿØ ÿØÿ± ŸÅÿßÿµŸÑŸáŸî ŸÖÿ¨ÿßÿ≤ ÿØÿßÿ±ŸÜÿØ'
                    : 'ÿ™ÿπÿØÿßÿØ ⁄©ŸÑ ÿ™ÿ∑ÿßÿ®ŸÇ‚ÄåŸáÿß€å ÿß€åŸÜ ŸÖŸàÿ±ÿØ ÿØÿ± ÿ¨ÿ≥ÿ™ÿ¨Ÿà';
                html += `<div class="item-stats-card"><div class="item-stats-header"><span class="item-stats-dot" style="background: var(--color-${colorIndex});"></span><span class="item-stats-title">${itemLabel}</span><span class="item-stats-type">${typeLabel}</span><span class="item-stats-total num-hindi" title="${matchesTitle}">${fmtFa(sec.totalMatches || 0)} ÿ™ÿ∑ÿßÿ®ŸÇ</span></div>`;
                if (!sec.rows || sec.rows.length === 0) {
                    html += `<div class="no-results">ÿØÿ± ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß€å ÿßŸÜÿ™ÿÆÿßÿ®‚Äåÿ¥ÿØŸá ŸÖŸàÿ±ÿØ€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ</div>`;
                } else {
                    const sortedRows = sortStatsRows(sec.rows);
                    html += `<table class="item-stats-table"><thead><tr>` +
                        `<th data-sort-key="sura" role="button" tabindex="0" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≥Ÿàÿ±Ÿá">ÿ≥Ÿàÿ±Ÿá${sortIndicatorFor('sura')}</th>` +
                        `<th data-sort-key="count" role="button" tabindex="0" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ™ÿπÿØÿßÿØ">ÿ™ÿπÿØÿßÿØ${sortIndicatorFor('count')}</th>` +
                        `<th data-sort-key="relInSura" role="button" tabindex="0" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÅÿ±ÿßŸàÿßŸÜ€å">ŸÅÿ±ÿßŸàÿßŸÜ€å${sortIndicatorFor('relInSura')}</th>` +
                        `<th data-sort-key="ratio" role="button" tabindex="0" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ™ŸÖÿß€åÿ≤">ÿ™ŸÖÿß€åÿ≤${sortIndicatorFor('ratio')}</th>` +
                        `<th data-sort-key="kl" role="button" tabindex="0" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ KL">KL${sortIndicatorFor('kl')}</th>` +
                        `<th data-sort-key="m" role="button" tabindex="0" title="ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ N¬≤/N">N¬≤/N${sortIndicatorFor('m')}</th>` +
                        `</tr></thead><tbody>`;
                    for (let r = 0; r < sortedRows.length; r++) {
                        const row = sortedRows[r];
                        html += `<tr><td><a class="stats-sura-link num-hindi" href="desktop.html?s=${row.sura}" title="ÿ®ÿßÿ≤ ⁄©ÿ±ÿØŸÜ ÿ≥Ÿàÿ±Ÿá ÿØÿ± €åÿ≥€åÿ±">${escapeHtml(SURA_NAMES[row.sura] || ('ÿ≥Ÿàÿ±Ÿá ' + fmtFa(row.sura)))}</a></td>`;
                        html += `<td class="num-hindi stats-sura-count" data-sura="${row.sura}" role="button" tabindex="0" title="ÿ™ÿπÿØÿßÿØ ÿ®ÿßÿ≤Ÿá‚ÄåŸáÿß ÿ®ÿß ŸáŸÖŸáŸî ŸÖŸàÿßÿ±ÿØÿå Ÿæ€åÿ¥ ÿßÿ≤ ÿßÿØÿ∫ÿßŸÖ (ŸÖŸÖ⁄©ŸÜ ÿßÿ≥ÿ™ ÿ®ÿß ÿ®ÿßÿ≤Ÿá‚ÄåŸáÿß€å ÿßÿØÿ∫ÿßŸÖ‚Äåÿ¥ÿØŸá ÿØÿ± ŸÜÿ™ÿß€åÿ¨ ÿ¨ÿ≥ÿ™ÿ¨Ÿà ŸÖÿ™ŸÅÿßŸàÿ™ ÿ®ÿßÿ¥ÿØ). ⁄©ŸÑ€å⁄©: ŸÅ€åŸÑÿ™ÿ± ÿ®Ÿá ÿß€åŸÜ ÿ≥Ÿàÿ±Ÿá Ÿà ŸÜŸÖÿß€åÿ¥ ŸÜÿ™ÿß€åÿ¨">${fmtFa(row.count)}</td>`;
                        html += `<td class="num-hindi measure-help" data-tooltip-html="${measureCellTooltip('freq', row).replace(/"/g, '&quot;')}">${fmtFaPercent(row.relInSura)}</td>`;
                        html += `<td class="num-hindi measure-help" data-tooltip-html="${measureCellTooltip('ratio', row).replace(/"/g, '&quot;')}">${fmtFaFloat(row.ratio, 3)}</td>`;
                        html += `<td class="num-hindi measure-help" data-tooltip-html="${measureCellTooltip('kl', row).replace(/"/g, '&quot;')}">${fmtFaFloat(row.kl, 4)}</td>`;
                        html += `<td class="num-hindi measure-help" data-tooltip-html="${measureCellTooltip('m', row).replace(/"/g, '&quot;')}">${fmtFaFloat(row.m, 3)}</td></tr>`;
                    }
                    html += `</tbody></table>`;
                }
                html += `</div>`;
            }
            resultsContent.innerHTML = html;
        }
        
        // Render results
        async function renderResults(groups) {
            const resultsBox = document.getElementById('results-box');
            const resultsContent = document.getElementById('results-content');
            const resultsCount = document.getElementById('results-count');
            const safeGroups = Array.isArray(groups) ? groups : [];
            
            resultsBox.style.display = 'flex';

            // Apply saved view / highlight settings
            const savedViewMode = localStorage.getItem('searchViewMode') || 'paragraph';
            const savedHighlightMode = localStorage.getItem('searchHighlightMode') || 'background';
            resultsBox.classList.toggle('view-rows', savedViewMode === 'rows');
            resultsBox.classList.toggle('highlight-text', savedHighlightMode === 'text');
            
            // Always build items panel
            buildItemsPanel();


            if (safeGroups.__combinedEligible !== undefined) {
                lastCombinedSearchMeta = {
                    bySura: safeGroups.__combinedCSBySura || {},
                    startsBySura: safeGroups.__combinedStartAyahsBySura || {},
                    startDebug: safeGroups.__combinedStartDebug || [],
                    totalCS: safeGroups.__combinedTotalCS || 0,
                    eligible: !!safeGroups.__combinedEligible
                };
            }

            if (safeGroups.length === 0) {
                resultsContent.innerHTML = '<div class="no-results">ŸÜÿ™€åÿ¨Ÿá‚Äåÿß€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ</div>';
                resultsCount.textContent = '';
                lastRenderedStats = [];
                return;
            }

            // Keep the normal found-items text unchanged even in stats mode.
            const uniqueIntervals = new Set(safeGroups.map(g => g.intervalId ?? g));
            resultsCount.textContent = `${fmtFa(uniqueIntervals.size)} ŸÖŸàÿ±ÿØ €åÿßŸÅÿ™ ÿ¥ÿØ`;
            resultsCount.title = buildSearchSummary();

            // In stats/table modes, render per-item/per-sura stats in-place of regions.
            if (searchResultsView === 'stats' || searchResultsView === 'charts') {
                lastRenderedGroups = safeGroups;
                const combinedData = safeGroups.__combinedEligible ? {
                    bySura: safeGroups.__combinedCSBySura || {},
                    startsBySura: safeGroups.__combinedStartAyahsBySura || {},
                    startDebug: safeGroups.__combinedStartDebug || [],
                    eligible: true
                } : null;
                const statsSections = performItemSuraStatsSearch(safeGroups.__statsInput, combinedData, statsMatchMode);
                if (searchResultsView === 'charts') renderStatsCharts(statsSections, resultsContent);
                else renderStatsResults(statsSections, resultsContent);
                return;
            }
            
            // If using QCF font, load data for all suras in results
            const useQCF = document.body.classList.contains('font-qurancom');
            if (useQCF) {
                const surasInResults = [...new Set(safeGroups.map(g => g.sura))];
                resultsContent.innerHTML = '<div class="qcf-loading">ÿØÿ± ÿ≠ÿßŸÑ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ŸÅŸàŸÜÿ™ quran.com...</div>';
                
                await Promise.all(surasInResults.map(sura => loadQCFDataForSura(sura)));
            }
            
            let html = '';
            let inMultiSuraContainer = false;
            
            // Keep a mutable reference for region controls actions
            lastRenderedGroups = safeGroups;
            // Ensure group keys exist
            for (let i = 0; i < lastRenderedGroups.length; i++) {
                if (!lastRenderedGroups[i].groupKey) {
                    const id = lastRenderedGroups[i].intervalId ?? 0;
                    lastRenderedGroups[i].groupKey = `g-${id}-${lastRenderedGroups[i].sura}-${i}`;
                }
                // Preserve original bounds for reset
                if (lastRenderedGroups[i].baseStartAyah === undefined) lastRenderedGroups[i].baseStartAyah = lastRenderedGroups[i].startAyah;
                if (lastRenderedGroups[i].baseEndAyah === undefined) lastRenderedGroups[i].baseEndAyah = lastRenderedGroups[i].endAyah;
            }

            for (const group of safeGroups) {
                // Handle multi-sura container
                if (group.isMultiSura) {
                    if (group.isFirstInInterval) {
                        html += `<div class="multi-sura-container">`;
                        inMultiSuraContainer = true;
                    }
                } else if (inMultiSuraContainer) {
                    html += `</div>`;
                    inMultiSuraContainer = false;
                }
                
                html += `<div class="result-group" data-group-key="${group.groupKey}">`;
                html += `<div class="region-controls">`;
                // Order and styling matches screenshot: blue down/down2, black up/up2, red X
                html += `<button type="button" class="region-btn after" data-action="after-1" title="ÿßŸÅÿ≤ŸàÿØŸÜ €± ÿ¢€åŸá ÿ®ÿπÿØ" aria-label="ÿßŸÅÿ≤ŸàÿØŸÜ €± ÿ¢€åŸá ÿ®ÿπÿØ">` +
                        `<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M2.2 4.5 6 8.3 9.8 4.5"/></svg>` +
                        `</button>`;
                html += `<button type="button" class="region-btn after" data-action="after-5" title="ÿßŸÅÿ≤ŸàÿØŸÜ €µ ÿ¢€åŸá ÿ®ÿπÿØ" aria-label="ÿßŸÅÿ≤ŸàÿØŸÜ €µ ÿ¢€åŸá ÿ®ÿπÿØ">` +
                        `<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">` +
                        `<path d="M2.2 3.7 6 7.5 9.8 3.7"/><path d="M2.2 6.0 6 9.8 9.8 6.0"/></svg>` +
                        `</button>`;
                html += `<button type="button" class="region-btn before" data-action="before-1" title="ÿßŸÅÿ≤ŸàÿØŸÜ €± ÿ¢€åŸá ŸÇÿ®ŸÑ" aria-label="ÿßŸÅÿ≤ŸàÿØŸÜ €± ÿ¢€åŸá ŸÇÿ®ŸÑ">` +
                        `<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M2.2 7.5 6 3.7 9.8 7.5"/></svg>` +
                        `</button>`;
                html += `<button type="button" class="region-btn before" data-action="before-5" title="ÿßŸÅÿ≤ŸàÿØŸÜ €µ ÿ¢€åŸá ŸÇÿ®ŸÑ" aria-label="ÿßŸÅÿ≤ŸàÿØŸÜ €µ ÿ¢€åŸá ŸÇÿ®ŸÑ">` +
                        `<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">` +
                        `<path d="M2.2 8.3 6 4.5 9.8 8.3"/><path d="M2.2 6.0 6 2.2 9.8 6.0"/></svg>` +
                        `</button>`;
                html += `<button type="button" class="region-btn reset" data-action="reset" title="ÿ®ÿßÿ≤ŸÜÿ¥ÿßŸÜ€å ÿß€åŸÜ ŸÜÿßÿ≠€åŸá" aria-label="ÿ®ÿßÿ≤ŸÜÿ¥ÿßŸÜ€å ÿß€åŸÜ ŸÜÿßÿ≠€åŸá">` +
                        `<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">` +
                        `<path d="M4.2 3.0H2.2v2.0"/><path d="M2.2 5.0a4.2 4.2 0 1 1 1.1 2.9"/></svg>` +
                        `</button>`;
                html += `<button type="button" class="region-btn danger" data-action="remove" title="ÿ≠ÿ∞ŸÅ ÿß€åŸÜ ŸÜÿßÿ≠€åŸá" aria-label="ÿ≠ÿ∞ŸÅ ÿß€åŸÜ ŸÜÿßÿ≠€åŸá">` +
                        `<svg viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"><path d="M3 3 9 9"/><path d="M9 3 3 9"/></svg>` +
                        `</button>`;
                html += `</div>`;
                html += `<div class="sura-row">`;

                // When a region is manually expanded, still highlight all searched items inside the expanded range
                const highlightMatchesForGroup = computeHighlightMatchesForGroup(group);
                
                for (let ayah = group.startAyah; ayah <= group.endAyah; ayah++) {
                    const ayahText = getAyahText(group.sura, ayah);
                    const highlightedText = highlightMatches(ayahText, group.sura, ayah, highlightMatchesForGroup);

                    const viewMode = localStorage.getItem('searchViewMode') || 'paragraph';
                    if (viewMode === 'rows') {
                        html += `<div class="ayah-row">`;
                        html += `<a class="ayah-ref-leading num-hindi" href="desktop.html?s=${group.sura}&a=${ayah}" title="ÿ®ÿßÿ≤ ⁄©ÿ±ÿØŸÜ ÿØÿ± €åÿ≥€åÿ±">${SURA_NAMES[group.sura]} ${fmtFa(ayah)}</a>`;
                        html += `<span class="result-ayah">${highlightedText}</span>`;
                        html += `</div>`;
                    } else {
                        html += `<span class="result-ayah">`;
                        html += highlightedText;
                        html += `<a class="result-ref num-hindi" href="desktop.html?s=${group.sura}&a=${ayah}" title="ÿ®ÿßÿ≤ ⁄©ÿ±ÿØŸÜ ÿØÿ± €åÿ≥€åÿ±">${SURA_NAMES[group.sura]} ${fmtFa(ayah)}</a>`;
                        html += `</span> `;
                    }
                }
                
                html += `</div>`;
                html += `</div>`;
                
                // Close multi-sura container after last group in interval
                if (group.isMultiSura && group.isLastInInterval) {
                    html += `</div>`;
                    inMultiSuraContainer = false;
                }
            }
            
            // Close any unclosed container
            if (inMultiSuraContainer) {
                html += `</div>`;
            }
            
            resultsContent.innerHTML = html;

            // Bind region controls (delegated)
            if (!resultsContent.dataset.regionControlsBound) {
                resultsContent.dataset.regionControlsBound = '1';
                resultsContent.addEventListener('click', (e) => {
                    const btn = e.target.closest('.region-btn');
                    if (!btn) return;
                    e.preventDefault();
                    e.stopPropagation();
                    const groupEl = btn.closest('.result-group');
                    const groupKey = groupEl?.dataset.groupKey;
                    const action = btn.dataset.action;
                    if (groupKey && action) {
                        applyRegionAction(groupKey, action);
                    }
                });
            }
        }
        
        function highlightMatches(text, sura, ayah, matches) {
            const ayahData = morphologyData[sura]?.[ayah];
            if (!ayahData) return text;
            
            const useQCF = document.body.classList.contains('font-qurancom');
            const wordIndices = Object.keys(ayahData).map(Number).sort((a, b) => a - b);
            const highlightedWords = [];
            
            for (const idx of wordIndices) {
                const word = ayahData[idx]?.text || '';
                const match = matches.find(m => m.sura === sura && m.ayah === ayah && m.wordIndex === idx);
                
                if (match) {
                    // Use itemIndex for color, default to 0
                    const colorIndex = (match.itemIndex ?? 0) % 8;
                    const highlightClass = `highlight highlight-${colorIndex}`;
                    
                    if (useQCF) {
                        highlightedWords.push(getQCFWordHTML(sura, ayah, idx, highlightClass));
                    } else {
                        highlightedWords.push(`<span class="${highlightClass}">${word}</span>`);
                    }
                } else {
                    if (useQCF) {
                        highlightedWords.push(getQCFWordHTML(sura, ayah, idx));
                    } else {
                        highlightedWords.push(word);
                    }
                }
            }
            
            return highlightedWords.join(' ');
        }
        
        // UI handlers
        function updateSelectedItemsUI() {
            const container = document.getElementById('selected-items');
            const searchBtn = document.getElementById('search-btn');
            const copyBtn = document.getElementById('copy-btn');
            
            if (selectedItems.length === 0) {
                container.innerHTML = '<span class="empty-hint">ŸÖŸàÿ±ÿØ€å ÿßŸÜÿ™ÿÆÿßÿ® ŸÜÿ¥ÿØŸá. Ÿàÿß⁄òŸá €åÿß ÿ±€åÿ¥Ÿá‚Äåÿß€å ÿ±ÿß ÿ¨ÿ≥ÿ™ÿ¨Ÿà Ÿà ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ.</span>';
                searchBtn.disabled = true;
                if (copyBtn) copyBtn.disabled = true;
            } else {
                const icons = ITEM_ICONS;
                container.innerHTML = selectedItems.map((item, index) => `
                    <div class="selected-item color-${index % 8}">
                        <span>${icons[item.type] || ''} ${item.display || item.value}</span>
                        <button class="remove-btn" data-index="${index}">√ó</button>
                    </div>
                `).join('');
                searchBtn.disabled = false;
                if (copyBtn) copyBtn.disabled = false;
            }
            if (typeof isEmbedMode !== 'undefined' && isEmbedMode) {
                const eb = document.getElementById('embed-add-btn');
                if (eb) eb.disabled = selectedItems.length === 0;
            }
        }
        
        function addSelectedItem(type, value, display) {
            // Check for duplicates
            if (selectedItems.some(item => item.type === type && item.value === value)) {
                return;
            }
            selectedItems.push({ type, value, display: display || value });
            updateSelectedItemsUI();
            requestAutoSearch(0);
        }
        
        function removeSelectedItem(index) {
            selectedItems.splice(index, 1);
            itemCheckedState.splice(index, 1);
            // Reset highlighted item if it's affected
            if (highlightedItem) {
                if (highlightedItem.itemIndex === index) {
                    highlightedItem = null;
                } else if (highlightedItem.itemIndex > index) {
                    highlightedItem.itemIndex--;
                }
            }
            updateSelectedItemsUI();
            requestAutoSearch(0);
        }
        
        // Embed mode: reusable inside other pages (e.g. desktop modal). ?embed=1&sure=74
        if (isEmbedMode) {
            document.body.classList.add('search-embed-mode');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const searchInput = document.getElementById('search-input');
            const suggestions = document.getElementById('suggestions');
            const selectedItemsContainer = document.getElementById('selected-items');
            const searchBtn = document.getElementById('search-btn');
            const resultsCountEl = document.getElementById('results-count');
            const resultsContentEl = document.getElementById('results-content');
            const distanceInput = document.getElementById('distance-input');
            const distanceDisplay = document.getElementById('distance-display');
            
            // Embed: show Add button, hide external links, listen for setSura
            if (isEmbedMode) {
                const embedAddBtn = document.getElementById('embed-add-btn');
                if (embedAddBtn) {
                    embedAddBtn.style.display = 'inline-block';
                    embedAddBtn.disabled = selectedItems.length === 0;
                }
                const goDesktop = document.getElementById('go-desktop-link');
                const goSimple = document.getElementById('go-simple-link');
                if (goDesktop) goDesktop.style.display = 'none';
                if (goSimple) goSimple.style.display = 'none';
                window.addEventListener('message', (e) => {
                    if (e.data && e.data.type === 'setSura' && typeof e.data.sure === 'number') {
                        const sura = Math.max(1, Math.min(114, e.data.sure));
                        allSurasSelected = false;
                        selectedSuras.clear();
                        selectedSuras.add(sura);
                        buildSuraFilterList();
                        updateSuraFilterLabel();
                    }
                });
            }
            
            // Load data, then apply URL params (e.g. from desktop tooltip links)
            loadMorphologyData().then(() => {
                const params = new URLSearchParams(window.location.search);
                const root = params.get('root');
                const lem = params.get('lem');
                const sure = params.get('sure');
                if (root && root.trim()) addSelectedItem('root', root.trim(), root.trim());
                if (lem && lem.trim()) addSelectedItem('text', lem.trim(), lem.trim());
                if (root || lem) {
                    const url = new URL(window.location.href);
                    url.searchParams.delete('root');
                    url.searchParams.delete('lem');
                    if (url.searchParams.toString()) url.search = '?' + url.searchParams.toString();
                    else url.search = '';
                    window.history.replaceState({}, '', url.toString());
                }
                if (isEmbedMode && sure && /^\d+$/.test(sure)) {
                    const suraNum = parseInt(sure, 10);
                    if (suraNum >= 1 && suraNum <= 114) {
                        allSurasSelected = false;
                        selectedSuras.clear();
                        selectedSuras.add(suraNum);
                        buildSuraFilterList();
                        updateSuraFilterLabel();
                    }
                }
            });

            // Distance control
            function updateDistanceDisplay() {
                if (!distanceDisplay || !distanceInput) return;
                const raw = parseDistanceFromValue(distanceInput.value);
                const v = Number.isFinite(raw) ? raw : 5;
                distanceDisplay.textContent = fmtFa(v);
            }
            function clampDistance() {
                const clamped = getDistanceValueClamped();
                setDistanceValueClamped(clamped);
                updateDistanceDisplay();
                requestAutoSearch(0);
                return clamped;
            }
            if (distanceInput) {
                updateDistanceDisplay();
                distanceInput.addEventListener('input', () => {
                    updateDistanceDisplay();
                    requestAutoSearch(250);
                });
                distanceInput.addEventListener('change', clampDistance);
                distanceInput.addEventListener('blur', clampDistance);
                distanceInput.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        e.preventDefault();
                        const v = clampDistance();
                        const next = e.key === 'ArrowUp' ? Math.min(100, v + 1) : Math.max(0, v - 1);
                        setDistanceValueClamped(next);
                        updateDistanceDisplay();
                    }
                });
                distanceInput.addEventListener('wheel', (e) => {
                    // Use wheel to increment/decrement without scrolling page
                    e.preventDefault();
                    const v = clampDistance();
                    const dir = e.deltaY < 0 ? 1 : -1;
                    setDistanceValueClamped(Math.max(0, Math.min(100, v + dir)));
                    updateDistanceDisplay();
                }, { passive: false });
            }
            
            // Search input handler
            let debounceTimer;
            searchInput.addEventListener('input', () => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    const query = searchInput.value.trim();
                    const results = getSuggestions(query);
                    
                    if (results.length > 0) {
                        const typeLabels = { root: 'ÿ±€åÿ¥Ÿá', word: 'Ÿàÿß⁄òŸá', text: 'ÿπÿ®ÿßÿ±ÿ™' };
                        suggestions.innerHTML = results.map(r => `
                            <div class="suggestion-item ${r.type}" data-type="${r.type}" data-value="${r.value}" data-display="${r.display.replace(/"/g, '&quot;')}">
                                <span>${r.icon} ${r.display}</span>
                                <span class="suggestion-type num-hindi">${typeLabels[r.type]} (${fmtFa(r.count)})</span>
                            </div>
                        `).join('');
                        suggestions.classList.add('visible');
                    } else {
                        suggestions.classList.remove('visible');
                    }
                }, 200);
            });
            
            // Suggestion click handler
            suggestions.addEventListener('click', (e) => {
                const item = e.target.closest('.suggestion-item');
                if (item) {
                    // For roots, use value as display (without sample words in parenthesis)
                    const display = item.dataset.type === 'root' ? item.dataset.value : item.dataset.display;
                    addSelectedItem(item.dataset.type, item.dataset.value, display);
                    searchInput.value = '';
                    suggestions.classList.remove('visible');
                    searchInput.focus(); // Focus back to search input
                }
            });
            
            // Remove item handler
            selectedItemsContainer.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-btn')) {
                    removeSelectedItem(parseInt(e.target.dataset.index));
                }
            });
            
            // Search button handler
            searchBtn.addEventListener('click', () => {
                triggerSearch();
            });

            // Embed: Add button sends current search to parent
            if (isEmbedMode) {
                const embedAddBtn = document.getElementById('embed-add-btn');
                function buildSearchDisplay() {
                    const distance = getDistanceValueClamped();
                    const crossSura = document.getElementById('cross-sura-toggle')?.getAttribute('aria-pressed') === 'true';
                    const parts = selectedItems
                        .map((item, idx) => itemCheckedState[idx] === false ? null : (item.type === 'root' ? item.value : item.type === 'text' ? item.value : `${item.type}:${item.value}`))
                        .filter(Boolean);
                    let display = parts.join('+');
                    if (distance) display += `[ŸÅ${fmtFa(distance)}]`;
                    // if (crossSura) display += ' ++';
                    return display;
                }
                function buildSearchDetails() {
                    const distance = getDistanceValueClamped();
                    const crossSura = document.getElementById('cross-sura-toggle')?.getAttribute('aria-pressed') === 'true';
                    const typeLabels = { root: 'ÿ±€åÿ¥Ÿá', text: 'ÿπÿ®ÿßÿ±ÿ™/Ÿàÿß⁄òŸá', word: 'Ÿàÿß⁄òŸá' };
                    const parts = [];
                    selectedItems.forEach((item, idx) => {
                        if (itemCheckedState[idx] === false) return;
                        const label = typeLabels[item.type] || item.type;
                        const val = (item.display || item.value || '').toString();
                        if (item.type === 'root' && rootLemData[item.value]) {
                            const lemData = rootLemData[item.value];
                            const selectedLems = lemData.lems.filter(l => l.selected);
                            const totalLems = lemData.lems.length;
                            if (selectedLems.length < totalLems && selectedLems.length > 0) {
                                parts.push(SearchShared.buildSearchDetailsLineForRoot(item.value, selectedLems.map(l => l.lem), selectedLems.length, totalLems));
                            } else {
                                parts.push(`${label}: ${val}`);
                            }
                        } else {
                            parts.push(`${label}: ${val}`);
                        }
                    });
                    let details = parts.join('\n');
                    if (distance) details += (details ? '\n' : '') + 'ŸÅÿßÿµŸÑŸá: ' + fmtFa(distance) + ' ÿ¢€åŸá';
                    if (crossSura) details += (details ? '\n' : '') + 'ÿ®€åŸÜ ÿ≥Ÿàÿ±Ÿá: ÿ®ŸÑŸá';
                    return details || '';
                }
                if (embedAddBtn) {
                    embedAddBtn.addEventListener('click', () => {
                        if (selectedItems.length === 0) return;
                        const distance = getDistanceValueClamped();
                        const crossSura = document.getElementById('cross-sura-toggle')?.getAttribute('aria-pressed') === 'true';
                        const display = buildSearchDisplay();
                        const searchDetails = buildSearchDetails();
                        let statsRows = [];
                        const groups = Array.isArray(lastRenderedGroups) ? lastRenderedGroups : [];
                        if (groups.length > 0 && groups.__statsInput) {
                            const combinedData = groups.__combinedEligible ? {
                                bySura: groups.__combinedCSBySura || {},
                                startsBySura: groups.__combinedStartAyahsBySura || {},
                                eligible: true
                            } : null;
                            const statsSections = performItemSuraStatsSearch(groups.__statsInput, combinedData, statsMatchMode);
                            if (statsSections.length > 0 && statsSections[0].rows) {
                                statsRows = statsSections[0].rows;
                            }
                        }
                        const regions = groups
                            .filter(g => g.matches && g.matches.length)
                            .map(g => ({
                                sura: g.sura,
                                startAyah: g.startAyah,
                                endAyah: g.endAyah,
                                matches: g.matches.map(m => ({ sura: m.sura, ayah: m.ayah, wordIndex: m.wordIndex }))
                            }));
                        // Detect "single root with single selected lemma" so desktop can use the exact same stats path as lemma "+"
                        let payloadRoot = null;
                        let payloadLemma = null;
                        const checkedItems = selectedItems.filter((item, i) => itemCheckedState[i] !== false);
                        if (checkedItems.length === 1 && checkedItems[0].type === 'root') {
                            payloadRoot = checkedItems[0].value;
                            const lemData = rootLemData[payloadRoot];
                            if (lemData && Array.isArray(lemData.lems)) {
                                const selectedLems = lemData.lems.filter(l => l.selected);
                                if (selectedLems.length === 1) payloadLemma = selectedLems[0].lem;
                            }
                        }
                        window.parent.postMessage({
                            type: 'addSearchItem',
                            items: selectedItems.map(i => ({ type: i.type, value: i.value, display: i.display || i.value })),
                            itemCheckedState: itemCheckedState.slice(),
                            distance,
                            crossSura,
                            display,
                            // For single root+single lemma, let desktop recompute via the shared function
                            statsRows: (payloadRoot && payloadLemma) ? null : statsRows,
                            searchDetails,
                            regions,
                            root: payloadRoot,
                            lemma: payloadLemma,
                            statsScopeSuras: allSurasSelected ? null : Array.from(selectedSuras)
                        }, '*');
                    });
                }
            }

            // Copy/send menu handling
            const copyBtn = document.getElementById('copy-btn');
            const copyMenu = document.getElementById('copy-menu');
            const copyResults = document.getElementById('copy-results');

            copyBtn.addEventListener('click', (e) => {
                if (copyBtn.disabled) return;
                e.stopPropagation();
                copyMenu.classList.toggle('visible');
            });

            copyResults.addEventListener('click', async (e) => {
                e.stopPropagation();
                const payloadText = buildCopyPayloadText();
                const payloadHtml = buildCopyPayloadHTML();
                await copyToClipboard({ text: payloadText, html: payloadHtml });
                copyMenu.classList.remove('visible');
            });

            // View toggle (regions / stats-table / stats-chart) - load initial state and sync button
            const viewResultsToggle = document.getElementById('view-results-toggle');
            function syncViewResultsToggle() {
                if (!viewResultsToggle) return;
                const mode = (searchResultsView === 'stats' || searchResultsView === 'charts') ? searchResultsView : 'regions';
                const modeLabel = mode === 'regions' ? 'ŸÖÿ™ŸÜ' : (mode === 'stats' ? 'ÿ¨ÿØŸàŸÑ' : 'ŸÜŸÖŸàÿØÿßÿ±');
                const nextLabel = mode === 'regions' ? 'ÿ¨ÿØŸàŸÑ' : (mode === 'stats' ? 'ŸÜŸÖŸàÿØÿßÿ±' : 'ŸÖÿ™ŸÜ');
                viewResultsToggle.setAttribute('aria-pressed', mode === 'regions' ? 'false' : 'true');
                viewResultsToggle.title = `ÿ≠ÿßŸÑÿ™ ŸÅÿπŸÑ€å: ${modeLabel} | ⁄©ŸÑ€å⁄©: ${nextLabel}`;
                viewResultsToggle.innerHTML = `<span class="view-results-dot" aria-hidden="true"></span>${modeLabel}`;
            }
            syncViewResultsToggle();
            if (viewResultsToggle) {
                viewResultsToggle.addEventListener('click', () => {
                    if (searchResultsView === 'regions') searchResultsView = 'stats';
                    else if (searchResultsView === 'stats') searchResultsView = 'charts';
                    else searchResultsView = 'regions';
                    localStorage.setItem(SEARCH_RESULTS_VIEW_STORAGE_KEY, searchResultsView);
                    syncViewResultsToggle();
                    renderResults(lastRenderedGroups || []);
                });
            }

            // Stats measure tooltip (delegated)
            if (resultsContentEl) {
                resultsContentEl.addEventListener('click', (e) => {
                    const sortHeader = e.target.closest('th[data-sort-key]');
                    if (sortHeader) {
                        e.preventDefault();
                        e.stopPropagation();
                        const key = sortHeader.getAttribute('data-sort-key');
                        if (key) {
                            if (statsSortKey === key) statsSortDir = (statsSortDir === 'asc') ? 'desc' : 'asc';
                            else { statsSortKey = key; statsSortDir = 'asc'; }
                            localStorage.setItem('searchStatsSortKey', statsSortKey);
                            localStorage.setItem('searchStatsSortDir', statsSortDir);
                            if (searchResultsView !== 'regions') renderResults(lastRenderedGroups || []);
                        }
                        return;
                    }
                    const sortDirBtn = e.target.closest('#stats-sort-dir');
                    if (sortDirBtn) {
                        e.preventDefault();
                        e.stopPropagation();
                        statsSortDir = (statsSortDir === 'asc') ? 'desc' : 'asc';
                        localStorage.setItem('searchStatsSortDir', statsSortDir);
                        if (searchResultsView !== 'regions') renderResults(lastRenderedGroups || []);
                        return;
                    }
                    const countCell = e.target.closest('.stats-sura-count');
                    if (countCell) {
                        e.preventDefault();
                        e.stopPropagation();
                        const sura = parseInt(countCell.dataset.sura, 10);
                        if (sura >= 1 && sura <= 114) {
                            allSurasSelected = false;
                            selectedSuras.clear();
                            selectedSuras.add(sura);
                            buildSuraFilterList();
                            updateSuraFilterLabel();
                            refreshRootLemDataForSuraFilter();
                            searchResultsView = 'regions';
                            localStorage.setItem(SEARCH_RESULTS_VIEW_STORAGE_KEY, searchResultsView);
                            syncViewResultsToggle();
                            triggerSearch();
                        }
                        return;
                    }
                    const toggle = e.target.closest('#stats-match-toggle');
                    if (!toggle) return;
                    e.preventDefault();
                    e.stopPropagation();
                    statsMatchMode = (statsMatchMode === 'any') ? 'all' : 'any';
                    localStorage.setItem('searchStatsMatchMode', statsMatchMode);
                    if (searchResultsView !== 'regions') renderResults(lastRenderedGroups || []);
                });
                resultsContentEl.addEventListener('change', (e) => {
                    const sel = e.target.closest('#stats-sort-select');
                    if (!sel) return;
                    const key = sel.value;
                    if (!key) return;
                    statsSortKey = key;
                    localStorage.setItem('searchStatsSortKey', statsSortKey);
                    if (searchResultsView !== 'regions') renderResults(lastRenderedGroups || []);
                });
                resultsContentEl.addEventListener('keydown', (e) => {
                    const sortHeader = e.target.closest('th[data-sort-key]');
                    if (sortHeader && (e.key === 'Enter' || e.key === ' ')) {
                        e.preventDefault();
                        sortHeader.click();
                        return;
                    }
                    const countCell = e.target.closest('.stats-sura-count');
                    if (countCell && (e.key === 'Enter' || e.key === ' ')) {
                        e.preventDefault();
                        countCell.click();
                    }
                });
                resultsContentEl.addEventListener('mouseover', (e) => {
                    const cell = e.target.closest('.measure-help');
                    if (!cell || !resultsContentEl.contains(cell)) return;
                    const html = cell.getAttribute('data-tooltip-html') || '';
                    if (!html) return;
                    showMeasureTooltip(html, cell);
                });
                resultsContentEl.addEventListener('mouseout', (e) => {
                    const from = e.target.closest('.measure-help');
                    if (!from) return;
                    const to = e.relatedTarget && e.relatedTarget.closest ? e.relatedTarget.closest('.measure-help') : null;
                    if (to && to === from) return;
                    hideMeasureTooltip();
                });
                resultsContentEl.addEventListener('mouseleave', () => {
                    hideMeasureTooltip();
                });
            }
            
            // Close suggestions on click outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-input-wrapper')) {
                    suggestions.classList.remove('visible');
                }
            });
            
            // Enter key to search
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && selectedItems.length > 0) {
                    searchBtn.click();
                }
            });

            // Cross-sura toggle button (no checkbox)
            const crossSuraToggle = document.getElementById('cross-sura-toggle');
            const savedCrossSura = localStorage.getItem('searchCrossSura') === 'true';
            if (crossSuraToggle) {
                crossSuraToggle.setAttribute('aria-pressed', savedCrossSura ? 'true' : 'false');
                crossSuraToggle.addEventListener('click', () => {
                    const next = crossSuraToggle.getAttribute('aria-pressed') !== 'true';
                    crossSuraToggle.setAttribute('aria-pressed', next ? 'true' : 'false');
                    localStorage.setItem('searchCrossSura', next ? 'true' : 'false');
                    requestAutoSearch(0);
                });
            }

            // Auto-update toggle (persist)
            const autoUpdateCb = document.getElementById('auto-update');
            if (autoUpdateCb) {
                const autoUpdatePill = document.getElementById('auto-update-toggle') || autoUpdateCb.closest('.auto-update-toggle');
                const syncAutoUpdatePill = () => {
                    if (!autoUpdatePill) return;
                    autoUpdatePill.classList.toggle('on', !!autoUpdateCb.checked);
                };
                const saved = localStorage.getItem('searchAutoUpdate');
                // Default: on. Only treat explicit 'false' as off.
                autoUpdateCb.checked = saved !== 'false';
                syncAutoUpdatePill();
                autoUpdateCb.addEventListener('change', () => {
                    localStorage.setItem('searchAutoUpdate', autoUpdateCb.checked ? 'true' : 'false');
                    syncAutoUpdatePill();
                    if (!autoUpdateCb.checked) {
                        // Cancel any scheduled auto search
                        if (__autoUpdateTimer) clearTimeout(__autoUpdateTimer);
                        __autoUpdateTimer = null;
                    } else {
                        requestAutoSearch(0);
                    }
                });
            }
            
            // Settings handling
            const settingsBtn = document.getElementById('settings-btn');
            const settingsMenu = document.getElementById('settings-menu');
            const fontSelect = document.getElementById('font-select');
            const viewModeSelect = document.getElementById('view-mode-select');
            const highlightModeSelect = document.getElementById('highlight-mode-select');
            const applySettings = document.getElementById('apply-settings');
            const goDesktopLink = document.getElementById('go-desktop-link');

            // Use a lightweight positioning library (Floating UI) instead of ad-hoc RTL/viewport logic
            let cleanupSettingsAutoUpdate = null;
            async function positionSettingsMenu() {
                const isRTL = getComputedStyle(document.documentElement).direction === 'rtl';
                const placement = isRTL ? 'bottom-end' : 'bottom-start';
                const { x, y } = await computePosition(settingsBtn, settingsMenu, {
                    strategy: 'fixed',
                    placement,
                    middleware: [
                        offset(6),
                        flip(),
                        shift({ padding: 8 })
                    ]
                });
                Object.assign(settingsMenu.style, {
                    left: `${x}px`,
                    top: `${y}px`
                });
            }

            function openSettingsMenu() {
                settingsMenu.classList.add('visible');
                // Update desktop link (prefer first result sura/ayah, then selected sura, else default 1)
                if (goDesktopLink) {
                    let sura = 1;
                    let ayah = null;
                    if (Array.isArray(lastRenderedGroups) && lastRenderedGroups.length > 0) {
                        sura = lastRenderedGroups[0].sura;
                        ayah = lastRenderedGroups[0].startAyah;
                    } else if (!allSurasSelected && selectedSuras.size === 1) {
                        sura = [...selectedSuras][0];
                    }
                    const url = new URL('desktop.html', window.location.href);
                    url.searchParams.set('s', String(sura));
                    if (ayah) url.searchParams.set('a', String(ayah));
                    goDesktopLink.href = url.toString();
                }
                // Start auto updates (resize/scroll/layout shifts)
                if (cleanupSettingsAutoUpdate) cleanupSettingsAutoUpdate();
                cleanupSettingsAutoUpdate = autoUpdate(settingsBtn, settingsMenu, positionSettingsMenu);
                positionSettingsMenu();
            }

            function closeSettingsMenu() {
                settingsMenu.classList.remove('visible');
                if (cleanupSettingsAutoUpdate) {
                    cleanupSettingsAutoUpdate();
                    cleanupSettingsAutoUpdate = null;
                }
            }
            
            // Load saved font preference
            const savedFont = localStorage.getItem('quranFont') || 'local';
            fontSelect.value = savedFont;
            applyFontSetting(savedFont);

            // Load saved view/highlight preferences
            const savedViewMode = localStorage.getItem('searchViewMode') || 'paragraph';
            const savedHighlightMode = localStorage.getItem('searchHighlightMode') || 'background';
            viewModeSelect.value = savedViewMode;
            highlightModeSelect.value = savedHighlightMode;
            
            function applyFontSetting(font) {
                if (font === 'qurancom') {
                    document.body.classList.add('font-qurancom');
                    document.body.classList.remove('font-bbadr');
                } else if (font === 'bbadr') {
                    document.body.classList.remove('font-qurancom');
                    document.body.classList.add('font-bbadr');
                } else {
                    document.body.classList.remove('font-qurancom');
                    document.body.classList.remove('font-bbadr');
                }
            }
            
            // Toggle settings menu
            settingsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (settingsMenu.classList.contains('visible')) {
                    closeSettingsMenu();
                } else {
                    openSettingsMenu();
                }
            });
            
            // Close settings on click outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.copy-menu') && !e.target.closest('.search-drop-btn')) {
                    copyMenu.classList.remove('visible');
                }
                if (!e.target.closest('.settings-menu') && !e.target.closest('.settings-btn')) {
                    closeSettingsMenu();
                }
            });
            
            // Apply settings
            applySettings.addEventListener('click', () => {
                const newFont = fontSelect.value;
                const currentFont = localStorage.getItem('quranFont') || 'local';
                const newViewMode = viewModeSelect.value;
                const newHighlightMode = highlightModeSelect.value;
                const currentViewMode = localStorage.getItem('searchViewMode') || 'paragraph';
                const currentHighlightMode = localStorage.getItem('searchHighlightMode') || 'background';

                // Persist view/highlight settings
                if (newViewMode !== currentViewMode) localStorage.setItem('searchViewMode', newViewMode);
                if (newHighlightMode !== currentHighlightMode) localStorage.setItem('searchHighlightMode', newHighlightMode);
                
                if (newFont !== currentFont) {
                    localStorage.setItem('quranFont', newFont);
                    // Reload page to apply font properly
                    location.reload();
                } else {
                    closeSettingsMenu();
                    // Re-render results to apply view/highlight immediately (no reload)
                    if (lastRenderedGroups && lastRenderedGroups.length) {
                        renderResults(lastRenderedGroups);
                    }
                }
            });
            
            // Sura filter
            const suraFilterBtn = document.getElementById('sura-filter-btn');
            const suraFilterPopup = document.getElementById('sura-filter-popup');
            const suraFilterList = document.getElementById('sura-filter-list');
            const suraFilterSearch = document.getElementById('sura-filter-search');
            const suraFilterLabel = document.getElementById('sura-filter-label');
            const suraSelectAll = document.getElementById('sura-select-all');
            const suraSelectNone = document.getElementById('sura-select-none');
            
            // Build sura list
            function buildSuraFilterList() {
                let html = '';
                for (let i = 1; i <= 114; i++) {
                    const name = SURA_NAMES[i] || `ÿ≥Ÿàÿ±Ÿá ${fmtFa(i)}`;
                    const isChecked = allSurasSelected || selectedSuras.has(i);
                    html += `<label class="sura-filter-item" data-sura="${i}" data-name="${name}">
                        <input type="checkbox" ${isChecked ? 'checked' : ''} data-sura="${i}">
                        <span class="sura-num num-hindi">${fmtFa(i)}</span>
                        <span class="sura-name">${name}</span>
                    </label>`;
                }
                suraFilterList.innerHTML = html;
                
                // Bind checkbox events
                suraFilterList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.addEventListener('change', () => {
                        const sura = parseInt(cb.dataset.sura);

                        if (allSurasSelected) {
                            // Switching from "all" mode: first uncheck means we go to individual mode
                            // Initialize selectedSuras with all EXCEPT this one
                            allSurasSelected = false;
                            selectedSuras.clear();
                            for (let s = 1; s <= 114; s++) {
                                if (s !== sura) selectedSuras.add(s);
                            }
                        } else {
                            // Individual mode
                            if (cb.checked) {
                                selectedSuras.add(sura);
                            } else {
                                selectedSuras.delete(sura);
                            }
                        }
                        updateSuraFilterLabel();
                        if (selectedItems.length > 0) {
                            refreshRootLemDataForSuraFilter();
                            triggerSearch();
                        }
                    });
                });
            }
            
            // Update label
            function updateSuraFilterLabel() {
                if (allSurasSelected) {
                    suraFilterLabel.textContent = 'ŸáŸÖŸá ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß';
                } else if (selectedSuras.size === 0) {
                    suraFilterLabel.textContent = 'Ÿá€å⁄Ü ÿ≥Ÿàÿ±Ÿá‚Äåÿß€å';
                } else if (selectedSuras.size === 114) {
                    suraFilterLabel.textContent = 'ŸáŸÖŸá ÿ≥Ÿàÿ±Ÿá‚ÄåŸáÿß';
                    allSurasSelected = true;
                    selectedSuras.clear();
                } else {
                    suraFilterLabel.innerHTML = `<span class="filter-count num-hindi">${fmtFa(selectedSuras.size)}</span> ÿ≥Ÿàÿ±Ÿá`;
                }
            }
            
            // Toggle popup
            suraFilterBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                suraFilterPopup.classList.toggle('visible');
                if (suraFilterPopup.classList.contains('visible')) {
                    buildSuraFilterList();
                }
            });

            suraFilterPopup.addEventListener('click', (e) => e.stopPropagation());
            
            // Close popup on outside click
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.sura-filter-popup') && !e.target.closest('.sura-filter-btn')) {
                    const wasVisible = suraFilterPopup.classList.contains('visible');
                    suraFilterPopup.classList.remove('visible');
                    if (wasVisible && selectedItems.length > 0) {
                        refreshRootLemDataForSuraFilter();
                        buildItemsPanel();
                        requestAutoSearch(0);
                    }
                }
            });
            
            function refreshRootLemDataForSuraFilter() {
                selectedItems.forEach((item) => {
                    if (item.type === 'root') initRootLemData(item.value, true);
                });
            }

            // Select all
            suraSelectAll.addEventListener('click', () => {
                allSurasSelected = true;
                selectedSuras.clear();
                buildSuraFilterList();
                updateSuraFilterLabel();
                refreshRootLemDataForSuraFilter();
                requestAutoSearch(0);
            });
            
            // Select none
            suraSelectNone.addEventListener('click', () => {
                allSurasSelected = false;
                selectedSuras.clear();
                suraFilterList.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateSuraFilterLabel();
                refreshRootLemDataForSuraFilter();
                requestAutoSearch(0);
            });
            
            // Search suras
            suraFilterSearch.addEventListener('input', () => {
                const query = suraFilterSearch.value.trim().toLowerCase();
                suraFilterList.querySelectorAll('.sura-filter-item').forEach(item => {
                    const name = item.dataset.name.toLowerCase();
                    const num = item.dataset.sura;
                    if (query === '' || name.includes(query) || num.includes(query)) {
                        item.classList.remove('hidden');
                    } else {
                        item.classList.add('hidden');
                    }
                });
            });

            buildSuraFilterList();
            updateSuraFilterLabel();
        });
    })();
    </script>
</body>
</html>

